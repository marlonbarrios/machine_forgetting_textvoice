import './style.css';
import p5 from 'p5';

// P_2_3_3_01
//
// Generative Gestaltung – Creative Coding im Web
// ISBN: 978-3-87439-902-9, First Edition, Hermann Schmidt, Mainz, 2018
// Benedikt Groß, Hartmut Bohnacker, Julia Laub, Claudius Lazzeroni
// with contributions by Joey Lee and Niels Poldervaart
// Copyright 2018
//
// http://www.generative-gestaltung.de
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * draw tool. shows how to draw with dynamic elements.
 *
 * MOUSE
 * drag                : draw with text
 *
 * KEYS
 * del, backspace      : clear screen
 * arrow up            : angle distortion +
 * arrow down          : angle distortion -
 * s                   : save png
 * space               : generate new text about speed and language
 */

'use strict';

// API routes for OpenAI (handled server-side to avoid CORS)
// Version: 2.0 - Using serverless functions instead of direct OpenAI calls
const API_BASE = '/api';

var x = 0;
var y = 0;
var stepSize = 5.0;
var font = 'Georgia';
var letters = ''; // No premade text - will be generated by AI
var fontSizeMin = 3;
var angleDistortion = 0.0;
var counter = 0;

// Text generation state
let isLoading = false;
let textReady = false; // Indicator for when text is ready (invisible)
let instructionText = 'Press SPACE to generate text, then move and click to draw.';
let hasGeneratedOnce = false;
let hasStartedDrawing = false; // Track if user has started drawing
let currentAudio = null; // Track current audio element
let shouldLoopAudio = false; // Track if audio should loop while mouse is pressed
let audioUrl = null; // Store audio URL for looping
let isAudioPlaying = false; // Flag to prevent multiple simultaneous audio calls
let autoGenerateInterval = null; // Interval for automatic text generation
let prevMouseX = 0; // Previous mouse X position for speed calculation
let prevMouseY = 0; // Previous mouse Y position for speed calculation
let drawnLetters = []; // Array to store drawn letters with their properties
let letterLifespan = 15000; // Lifespan in milliseconds (15 seconds - 100% longer)
let showHomePage = true; // Show home page until user starts
let selectedLanguage = 'en'; // Default language: English
let showLanguageMenu = true; // Show language menu
let languageMenuOpen = false; // Track if dropdown is open
let darkMode = false; // Light mode by default
let spacePressed = false; // Track if space bar has been pressed
let textReadyIndicatorTime = 0; // Track when text becomes ready (for showing indicator) - 0 means not set yet
let audioReady = false; // Track if audio is ready to play
let audioDuration = 0; // Track audio duration for synchronization
let lastDrawnCharIndex = -1; // Track last character index drawn based on audio position
let audioStartTime = 0; // Track when audio started playing for synchronization

// Language definitions with translations (30 languages)
const languages = {
  'en': { name: 'English', native: 'English' },
  'es': { name: 'Spanish', native: 'Español' },
  'fr': { name: 'French', native: 'Français' },
  'de': { name: 'German', native: 'Deutsch' },
  'zh': { name: 'Chinese', native: '中文' },
  'ja': { name: 'Japanese', native: '日本語' },
  'ar': { name: 'Arabic', native: 'العربية' },
  'pt': { name: 'Portuguese', native: 'Português' },
  'ru': { name: 'Russian', native: 'Русский' },
  'hi': { name: 'Hindi', native: 'हिन्दी' },
  'it': { name: 'Italian', native: 'Italiano' },
  'ko': { name: 'Korean', native: '한국어' },
  'tr': { name: 'Turkish', native: 'Türkçe' },
  'pl': { name: 'Polish', native: 'Polski' },
  'nl': { name: 'Dutch', native: 'Nederlands' },
  'sv': { name: 'Swedish', native: 'Svenska' },
  'no': { name: 'Norwegian', native: 'Norsk' },
  'da': { name: 'Danish', native: 'Dansk' },
  'fi': { name: 'Finnish', native: 'Suomi' },
  'el': { name: 'Greek', native: 'Ελληνικά' },
  'cs': { name: 'Czech', native: 'Čeština' },
  'ro': { name: 'Romanian', native: 'Română' },
  'hu': { name: 'Hungarian', native: 'Magyar' },
  'th': { name: 'Thai', native: 'ไทย' },
  'vi': { name: 'Vietnamese', native: 'Tiếng Việt' },
  'id': { name: 'Indonesian', native: 'Bahasa Indonesia' },
  'he': { name: 'Hebrew', native: 'עברית' },
  'uk': { name: 'Ukrainian', native: 'Українська' },
  'ca': { name: 'Catalan', native: 'Català' },
  'ms': { name: 'Malay', native: 'Bahasa Melayu' }
};

// Translations for instructions
const translations = {
  'en': {
    title: 'Machine Forgetting',
    subtitle1: 'Language unfolds in time • Words fade through pathways •',
    subtitle2: 'Memory erodes • Form decays • Autoregressive sequences',
    subtitle3: 'Traces of programmed decay and the upheavals of entropy',
    instruction: 'Select language, press SPACE to generate text, then move and click to draw',
    hint: 'Move vertically to control volume • Speed affects playback rate and font size',
    generatingText: 'Generating text...',
    generatingAudio: 'Generating audio...',
    textReady: 'Text ready • Click and drag to draw',
    pressSpace: 'Press SPACE to generate text',
    systemPrompt: 'Write a short text in English in the style of Samuel Beckett - sparse, minimal, repetitive, existential. Base it in computation and autoregressive processes. About forgetting in computation, context windows, autoregressive sequences, token limits, memory constraints. Preprogrammed dissipation. Dissipative processes. How autoregressive models predict the next token, lose context, forget earlier tokens. Computational forgetting. Context dissipation. Sequence limits. Memory bounds. Preprogrammed dissipation built into systems. Traces. Form emerges. Grows. Decays. Dissipates. The work itself embodies these processes. Form through drawing. Growth with gesture. Decay as letters fade. Dissipation into nothingness. Time passing as entropy. Form as memory. Time flows. Entropy increases. Form holds. Memory fades. Use short clipped sentences. Repetition. Fragmented thoughts. Questions without answers. Silence between words. Monotone rhythm. Focus on computational dissipation, dissipative systems, nothingness, waiting, erasure, traces, preprogrammed dissipation, form, growth, decay, dissipation, time as entropy, form as memory. Less poetic, more stark. No flowery language. Direct. Brutal simplicity. About forgetting everything in computation. Losing all context in autoregressive processes. The necessity and fear of computational forgetting. Preprogrammed dissipation. Traces left behind. Write in Beckett\'s style - sparse, repetitive, existential, computational. Write the entire response in English. Suitable for drawing with text. Make it concise, around 100-150 characters.'
  },
  'es': {
    title: 'Olvido de Máquina',
    subtitle1: 'El lenguaje se despliega en el tiempo • Las palabras se desvanecen por caminos •',
    subtitle2: 'La memoria se erosiona • La forma decae • Secuencias autorregresivas',
    subtitle3: 'Trazas de decaimiento programado y las convulsiones de la entropía',
    instruction: 'Selecciona idioma, presiona ESPACIO para generar texto, luego mueve y haz clic para dibujar',
    hint: 'Mueve verticalmente para controlar el volumen • La velocidad afecta la velocidad de reproducción y el tamaño de fuente',
    generatingText: 'Generando texto...',
    generatingAudio: 'Generando audio...',
    textReady: 'Texto listo • Haz clic y arrastra para dibujar',
    pressSpace: 'Presiona ESPACIO para generar texto',
    systemPrompt: 'Escribe un texto corto en español en el estilo de Samuel Beckett - escaso, minimalista, repetitivo, existencial. Basado en computación y procesos autorregresivos. Sobre el olvido en la computación, ventanas de contexto, secuencias autorregresivas, límites de tokens, restricciones de memoria. Disipación preprogramada. Procesos disipativos. Cómo los modelos autorregresivos predicen el siguiente token, pierden contexto, olvidan tokens anteriores. Olvido computacional. Disipación de contexto. Límites de secuencia. Límites de memoria. Disipación preprogramada integrada en sistemas. Trazas. La forma emerge. Crece. Decae. Se disipa. La obra misma encarna estos procesos. Forma a través del dibujo. Crecimiento con el gesto. Decaimiento mientras las letras se desvanecen. Disipación en la nada. El tiempo pasa como entropía. La forma como memoria. El tiempo fluye. La entropía aumenta. La forma sostiene. La memoria se desvanece. Usa frases cortas y cortadas. Repetición. Pensamientos fragmentados. Preguntas sin respuestas. Silencio entre palabras. Ritmo monótono. Enfócate en disipación computacional, sistemas disipativos, nada, espera, borrado, trazas, disipación preprogramada, forma, crecimiento, decaimiento, disipación, tiempo como entropía, forma como memoria. Menos poético, más crudo. Sin lenguaje florido. Directo. Simplicidad brutal. Sobre olvidar todo en la computación. Perder todo el contexto en procesos autorregresivos. La necesidad y el miedo del olvido computacional. Disipación preprogramada. Trazas dejadas atrás. Escribe en el estilo de Beckett - escaso, repetitivo, existencial, computacional. Escribe toda la respuesta en español. Adecuado para dibujar con texto. Hazlo conciso, alrededor de 100-150 caracteres.'
  },
  'fr': {
    title: 'Oubli Machine',
    subtitle1: 'Le langage se déploie dans le temps • Les mots s\'effacent par des chemins •',
    subtitle2: 'La mémoire s\'érode • La forme se décompose • Séquences autorégressives',
    subtitle3: 'Traces de décomposition programmée et les bouleversements de l\'entropie',
    instruction: 'Sélectionnez la langue, appuyez sur ESPACE pour générer du texte, puis déplacez et cliquez pour dessiner',
    hint: 'Déplacez verticalement pour contrôler le volume • La vitesse affecte la vitesse de lecture et la taille de la police',
    generatingText: 'Génération du texte...',
    generatingAudio: 'Génération de l\'audio...',
    textReady: 'Texte prêt • Cliquez et glissez pour dessiner',
    pressSpace: 'Appuyez sur ESPACE pour générer du texte',
    systemPrompt: 'Écris un court texte en français dans le style de Samuel Beckett - sobre, minimal, répétitif, existentiel. Basé sur la computation et les processus autorégressifs. Sur l\'oubli en computation, fenêtres de contexte, séquences autorégressives, limites de tokens, contraintes de mémoire. Dissipation préprogrammée. Processus dissipatifs. Comment les modèles autorégressifs prédisent le token suivant, perdent le contexte, oublient les tokens précédents. Oubli computationnel. Dissipation de contexte. Limites de séquence. Limites de mémoire. Dissipation préprogrammée intégrée aux systèmes. Traces. La forme émerge. Croît. Décroît. Se dissipe. L\'œuvre elle-même incarne ces processus. Forme à travers le dessin. Croissance avec le geste. Décroissance alors que les lettres s\'effacent. Dissipation dans le néant. Le temps passe comme entropie. La forme comme mémoire. Le temps coule. L\'entropie augmente. La forme tient. La mémoire s\'efface. Utilise des phrases courtes et coupées. Répétition. Pensées fragmentées. Questions sans réponses. Silence entre les mots. Rythme monotone. Concentre-toi sur la dissipation computationnelle, les systèmes dissipatifs, le néant, l\'attente, l\'effacement, les traces, la dissipation préprogrammée, forme, croissance, décroissance, dissipation, temps comme entropie, forme comme mémoire. Moins poétique, plus brutal. Pas de langage fleuri. Direct. Simplicité brutale. Sur l\'oubli de tout en computation. Perdre tout contexte dans les processus autorégressifs. La nécessité et la peur de l\'oubli computationnel. Dissipation préprogrammée. Traces laissées derrière. Écris dans le style de Beckett - sobre, répétitif, existentiel, computationnel. Écris toute la réponse en français. Adapté pour dessiner avec du texte. Sois concis, environ 100-150 caractères.'
  },
  'de': {
    title: 'Maschinelles Vergessen',
    subtitle1: 'Sprache entfaltet sich in der Zeit • Wörter verblassen durch Pfade •',
    subtitle2: 'Gedächtnis erodiert • Form zerfällt • Autoregressive Sequenzen',
    subtitle3: 'Spuren des programmierten Zerfalls und die Umwälzungen der Entropie',
    instruction: 'Sprache auswählen, LEERTASTE drücken, um Text zu generieren, dann bewegen und klicken zum Zeichnen',
    hint: 'Vertikal bewegen, um die Lautstärke zu steuern • Geschwindigkeit beeinflusst Wiedergabegeschwindigkeit und Schriftgröße',
    generatingText: 'Text wird generiert...',
    generatingAudio: 'Audio wird generiert...',
    textReady: 'Text bereit • Klicken und ziehen zum Zeichnen',
    pressSpace: 'LEERTASTE drücken, um Text zu generieren',
    systemPrompt: 'Schreibe einen kurzen Text auf Deutsch im Stil von Samuel Beckett - spärlich, minimal, repetitiv, existenziell. Basierend auf Berechnung und autoregressiven Prozessen. Über das Vergessen in der Berechnung, Kontextfenster, autoregressive Sequenzen, Token-Limits, Speicherbeschränkungen. Vorprogrammierte Dissipation. Dissipative Prozesse. Wie autoregressive Modelle den nächsten Token vorhersagen, Kontext verlieren, frühere Tokens vergessen. Berechnungsvergessen. Kontextdissipation. Sequenzgrenzen. Speichergrenzen. Vorprogrammierte Dissipation in Systemen eingebaut. Spuren. Form entsteht. Wächst. Verfällt. Dissipiert. Das Werk selbst verkörpert diese Prozesse. Form durch Zeichnen. Wachstum mit Geste. Verfall während Buchstaben verblassen. Dissipation ins Nichts. Zeit vergeht als Entropie. Form als Gedächtnis. Zeit fließt. Entropie steigt. Form hält. Gedächtnis verblasst. Verwende kurze, abgehackte Sätze. Wiederholung. Fragmentierte Gedanken. Fragen ohne Antworten. Stille zwischen Wörtern. Monotoner Rhythmus. Konzentriere dich auf berechnungsmäßige Dissipation, dissipative Systeme, Nichts, Warten, Löschung, Spuren, vorprogrammierte Dissipation, Form, Wachstum, Verfall, Dissipation, Zeit als Entropie, Form als Gedächtnis. Weniger poetisch, schroffer. Keine blumige Sprache. Direkt. Brutale Einfachheit. Über das Vergessen von allem in der Berechnung. Verlust des gesamten Kontexts in autoregressiven Prozessen. Die Notwendigkeit und Angst vor berechnungsmäßigem Vergessen. Vorprogrammierte Dissipation. Zurückgelassene Spuren. Schreibe im Stil von Beckett - spärlich, repetitiv, existenziell, berechnungsmäßig. Schreibe die gesamte Antwort auf Deutsch. Geeignet zum Zeichnen mit Text. Sei prägnant, etwa 100-150 Zeichen.'
  },
  'zh': {
    title: '机器遗忘',
    subtitle1: '语言在时间中展开 • 文字通过路径消逝 •',
    subtitle2: '记忆侵蚀 • 形式衰败 • 自回归序列',
    subtitle3: '程序化衰变的痕迹与熵的动荡',
    instruction: '选择语言，按空格键生成文本，然后移动并点击绘制',
    hint: '垂直移动控制音量 • 速度影响播放速率和字体大小',
    generatingText: '正在生成文本...',
    generatingAudio: '正在生成音频...',
    textReady: '文本就绪 • 点击并拖动以绘制',
    pressSpace: '按空格键生成文本',
    systemPrompt: '用中文写一段简短的文本，采用塞缪尔·贝克特的风格——稀疏、极简、重复、存在主义。基于计算和自回归过程。关于计算中的遗忘、上下文窗口、自回归序列、令牌限制、内存约束。预编程耗散。耗散过程。自回归模型如何预测下一个令牌、丢失上下文、忘记先前的令牌。计算遗忘。上下文耗散。序列限制。内存边界。内置系统的预编程耗散。痕迹。形式出现。生长。衰败。耗散。作品本身体现这些过程。通过绘画的形式。随姿态生长。随字母消逝而衰败。耗散为虚无。时间流逝如熵。形式如记忆。时间流动。熵增加。形式保持。记忆消逝。使用简短截断的句子。重复。碎片化的思想。没有答案的问题。词语之间的沉默。单调的节奏。专注于计算耗散、耗散系统、虚无、等待、擦除、痕迹、预编程耗散、形式、生长、衰败、耗散、时间如熵、形式如记忆。少诗意，更生硬。不要华丽的语言。直接。残酷的简单。关于在计算中忘记一切。在自回归过程中失去所有上下文。计算遗忘的必要性和恐惧。预编程耗散。留下的痕迹。用贝克特的风格写作——稀疏、重复、存在主义、计算性。整个回答用中文写。适合用文本绘制。简洁，约100-150个字符。'
  },
  'ja': {
    title: '機械の忘却',
    subtitle1: '言語は時間の中で展開する • 言葉は経路を通じて消えていく •',
    subtitle2: '記憶は侵食される • 形は崩壊する • 自己回帰シーケンス',
    subtitle3: 'プログラム化された崩壊の痕跡とエントロピーの激動',
    instruction: '言語を選択し、スペースキーを押してテキストを生成し、移動してクリックして描画',
    hint: '垂直に移動して音量を制御 • 速度が再生速度とフォントサイズに影響',
    generatingText: 'テキストを生成中...',
    generatingAudio: 'オーディオを生成中...',
    textReady: 'テキスト準備完了 • クリックしてドラッグして描画',
    pressSpace: 'スペースキーを押してテキストを生成',
    systemPrompt: 'サミュエル・ベケットのスタイルで日本語の短いテキストを書いてください - まばら、最小限、反復的、実存主義的。計算と自己回帰プロセスに基づく。計算における忘却、コンテキストウィンドウ、自己回帰シーケンス、トークン制限、メモリ制約について。事前プログラムされた散逸。散逸プロセス。自己回帰モデルが次のトークンを予測し、コンテキストを失い、以前のトークンを忘れる方法。計算的忘却。コンテキスト散逸。シーケンス制限。メモリ境界。システムに組み込まれた事前プログラムされた散逸。痕跡。形式が現れる。成長する。衰退する。散逸する。作品自体がこれらのプロセスを体現する。描画を通じた形式。ジェスチャーによる成長。文字が消えるにつれての衰退。無への散逸。時間がエントロピーとして過ぎる。形式が記憶として。時間が流れる。エントロピーが増加する。形式が保持する。記憶が消える。短い切り取られた文を使用。反復。断片的な思考。答えのない質問。単語間の沈黙。単調なリズム。計算的散逸、散逸システム、無、待機、消去、痕跡、事前プログラムされた散逸、形式、成長、衰退、散逸、時間としてのエントロピー、形式としての記憶に焦点を当てる。詩的でなく、より厳格に。華やかな言語なし。直接的。残酷な単純さ。計算ですべてを忘れることについて。自己回帰プロセスでコンテキストをすべて失うこと。計算的忘却の必要性と恐怖。事前プログラムされた散逸。残された痕跡。ベケットのスタイルで書く - まばら、反復的、実存主義的、計算的。回答全体を日本語で書く。テキストで描画するのに適している。簡潔に、約100-150文字。'
  },
  'ar': {
    title: 'نسيان الآلة',
    subtitle1: 'تتكشف اللغة في الزمن • تذبل الكلمات عبر المسارات •',
    subtitle2: 'الذاكرة تتآكل • الشكل يتحلل • تسلسلات انحدارية ذاتية',
    subtitle3: 'آثار الانحلال المبرمج واضطرابات الإنتروبيا',
    instruction: 'اختر اللغة، اضغط على المسافة لتوليد النص، ثم حرك وانقر للرسم',
    hint: 'تحرك عمودياً للتحكم في الصوت • السرعة تؤثر على معدل التشغيل وحجم الخط',
    generatingText: 'جاري توليد النص...',
    generatingAudio: 'جاري توليد الصوت...',
    textReady: 'النص جاهز • انقر واسحب للرسم',
    pressSpace: 'اضغط على المسافة لتوليد النص',
    systemPrompt: 'اكتب نصًا قصيرًا بالعربية بأسلوب صامويل بيكيت - مقتضب، بسيط، متكرر، وجودي. قائم على الحساب والعمليات الانحدارية الذاتية. حول النسيان في الحساب، نوافذ السياق، التسلسلات الانحدارية الذاتية، حدود الرموز، قيود الذاكرة. التبديد المبرمج مسبقًا. العمليات المبددة. كيف تتنبأ النماذج الانحدارية الذاتية بالرمز التالي، تفقد السياق، تنسى الرموز السابقة. النسيان الحسابي. تبديد السياق. حدود التسلسل. حدود الذاكرة. التبديد المبرمج مسبقًا المدمج في الأنظمة. الآثار. الشكل يظهر. ينمو. يتحلل. يتبدد. العمل نفسه يجسد هذه العمليات. الشكل من خلال الرسم. النمو مع الإيماءة. التحلل مع تلاشي الحروف. التبديد إلى العدم. الوقت يمر كالإنتروبيا. الشكل كالذاكرة. الوقت يتدفق. الإنتروبيا تزداد. الشكل يحتفظ. الذاكرة تتلاشى. استخدم جملًا قصيرة مقطوعة. التكرار. أفكار مجزأة. أسئلة بلا إجابات. صمت بين الكلمات. إيقاع رتيب. ركز على التبديد الحسابي، الأنظمة المبددة، العدم، الانتظار، المحو، الآثار، التبديد المبرمج مسبقًا، الشكل، النمو، التحلل، التبديد، الوقت كالإنتروبيا، الشكل كالذاكرة. أقل شاعرية، أكثر قسوة. لا لغة مزخرفة. مباشر. بساطة قاسية. حول نسيان كل شيء في الحساب. فقدان كل السياق في العمليات الانحدارية الذاتية. ضرورة وخوف النسيان الحسابي. التبديد المبرمج مسبقًا. الآثار المتروكة. اكتب بأسلوب بيكيت - مقتضب، متكرر، وجودي، حسابي. اكتب الرد كله بالعربية. مناسب للرسم بالنص. اجعله مختصرًا، حوالي 100-150 حرفًا.'
  },
  'pt': {
    title: 'Esquecimento de Máquina',
    subtitle1: 'A linguagem se desdobra no tempo • As palavras desaparecem por caminhos •',
    subtitle2: 'A memória se erode • A forma decai • Sequências autorregressivas',
    subtitle3: 'Traços de decaimento programado e as convulsões da entropia',
    instruction: 'Selecione o idioma, pressione ESPAÇO para gerar texto, depois mova e clique para desenhar',
    hint: 'Mova verticalmente para controlar o volume • A velocidade afeta a taxa de reprodução e o tamanho da fonte',
    generatingText: 'Gerando texto...',
    generatingAudio: 'Gerando áudio...',
    textReady: 'Texto pronto • Clique e arraste para desenhar',
    pressSpace: 'Pressione ESPAÇO para gerar texto',
    systemPrompt: 'Escreva um texto curto em português no estilo de Samuel Beckett - esparso, minimal, repetitivo, existencial. Baseado em computação e processos autorregressivos. Sobre esquecimento em computação, janelas de contexto, sequências autorregressivas, limites de tokens, restrições de memória. Dissipação pré-programada. Processos dissipativos. Como modelos autorregressivos preveem o próximo token, perdem contexto, esquecem tokens anteriores. Esquecimento computacional. Dissipação de contexto. Limites de sequência. Limites de memória. Dissipação pré-programada integrada em sistemas. Traços. A forma emerge. Cresce. Decai. Dissipa-se. A obra mesma encarna estes processos. Forma através do desenho. Crescimento com o gesto. Decaimento enquanto as letras se desvanacem. Dissipação no nada. O tempo passa como entropia. A forma como memória. O tempo flui. A entropia aumenta. A forma mantém. A memória desvanece. Use frases curtas e cortadas. Repetição. Pensamentos fragmentados. Perguntas sem respostas. Silêncio entre palavras. Ritmo monótono. Foque em dissipação computacional, sistemas dissipativos, nada, espera, apagamento, traços, dissipação pré-programada, forma, crescimento, decaimento, dissipação, tempo como entropia, forma como memória. Menos poético, mais cru. Sem linguagem florida. Direto. Simplicidade brutal. Sobre esquecer tudo em computação. Perder todo contexto em processos autorregressivos. A necessidade e o medo do esquecimento computacional. Dissipação pré-programada. Traços deixados para trás. Escreva no estilo de Beckett - esparso, repetitivo, existencial, computacional. Escreva toda a resposta em português. Adequado para desenhar com texto. Seja conciso, cerca de 100-150 caracteres.'
  },
  'ru': {
    title: 'Машинное Забвение',
    subtitle1: 'Язык разворачивается во времени • Слова исчезают по путям •',
    subtitle2: 'Память разрушается • Форма распадается • Авторегрессивные последовательности',
    subtitle3: 'Следы запрограммированного распадения и потрясения энтропии',
    instruction: 'Выберите язык, нажмите ПРОБЕЛ для генерации текста, затем перемещайте и кликайте для рисования',
    hint: 'Двигайтесь вертикально для управления громкостью • Скорость влияет на скорость воспроизведения и размер шрифта',
    generatingText: 'Генерация текста...',
    generatingAudio: 'Генерация аудио...',
    textReady: 'Текст готов • Нажмите и перетащите для рисования',
    pressSpace: 'Нажмите ПРОБЕЛ для генерации текста',
    systemPrompt: 'Напиши короткий текст на русском языке в стиле Сэмюэля Беккета - скудный, минималистичный, повторяющийся, экзистенциальный. Основанный на вычислениях и авторегрессивных процессах. О забвении в вычислениях, окнах контекста, авторегрессивных последовательностях, ограничениях токенов, ограничениях памяти. Запрограммированная диссипация. Диссипативные процессы. Как авторегрессивные модели предсказывают следующий токен, теряют контекст, забывают предыдущие токены. Вычислительное забвение. Диссипация контекста. Ограничения последовательности. Границы памяти. Запрограммированная диссипация, встроенная в системы. Следы. Форма возникает. Растёт. Распадается. Диссипирует. Само произведение воплощает эти процессы. Форма через рисование. Рост с жестом. Распад по мере исчезновения букв. Диссипация в ничто. Время проходит как энтропия. Форма как память. Время течёт. Энтропия растёт. Форма держит. Память угасает. Используй короткие обрезанные предложения. Повторение. Фрагментированные мысли. Вопросы без ответов. Тишина между словами. Монотонный ритм. Сосредоточься на вычислительной диссипации, диссипативных системах, ничто, ожидание, стирание, следы, запрограммированная диссипация, форма, рост, распад, диссипация, время как энтропия, форма как память. Меньше поэтичности, более резко. Без цветистого языка. Прямо. Жестокая простота. О забвении всего в вычислениях. Потеря всего контекста в авторегрессивных процессах. Необходимость и страх вычислительного забвения. Запрограммированная диссипация. Оставленные следы. Пиши в стиле Беккета - скудно, повторяюще, экзистенциально, вычислительно. Напиши весь ответ на русском языке. Подходит для рисования текстом. Будь лаконичен, около 100-150 символов.'
  },
  'hi': {
    title: 'मशीन भूल',
    subtitle1: 'भाषा समय में खुलती है • शब्द रास्तों से फीके पड़ते हैं •',
    subtitle2: 'स्मृति कटती है • रूप नष्ट होता है • स्व-प्रतिगामी अनुक्रम',
    subtitle3: 'प्रोग्राम किए गए क्षय के निशान और एन्ट्रॉपी के उथल-पुथल',
    instruction: 'भाषा चुनें, पाठ उत्पन्न करने के लिए SPACE दबाएं, फिर खींचने के लिए स्थानांतरित करें और क्लिक करें',
    hint: 'मात्रा नियंत्रित करने के लिए लंबवत स्थानांतरित करें • गति प्लेबैक दर और फ़ॉन्ट आकार को प्रभावित करती है',
    generatingText: 'पाठ उत्पन्न हो रहा है...',
    generatingAudio: 'ऑडियो उत्पन्न हो रहा है...',
    textReady: 'पाठ तैयार • खींचने के लिए क्लिक करें और खींचें',
    pressSpace: 'पाठ उत्पन्न करने के लिए SPACE दबाएं',
    systemPrompt: 'सैमुअल बेकेट की शैली में हिंदी में एक छोटा पाठ लिखें - विरल, न्यूनतम, दोहरावपूर्ण, अस्तित्ववादी। गणना और स्व-प्रतिगामी प्रक्रियाओं पर आधारित। गणना में भूलने के बारे में, संदर्भ विंडो, स्व-प्रतिगामी अनुक्रम, टोकन सीमाएं, स्मृति बाधाएं। पूर्व-प्रोग्राम किया गया क्षय। क्षयकारी प्रक्रियाएं। कैसे स्व-प्रतिगामी मॉडल अगले टोकन की भविष्यवाणी करते हैं, संदर्भ खो देते हैं, पिछले टोकन भूल जाते हैं। कम्प्यूटेशनल भूलना। संदर्भ क्षय। अनुक्रम सीमाएं। स्मृति सीमाएं। सिस्टम में निर्मित पूर्व-प्रोग्राम किया गया क्षय। निशान। रूप उभरता है। बढ़ता है। क्षय होता है। विलीन हो जाता है। कार्य स्वयं इन प्रक्रियाओं को मूर्त रूप देता है। चित्रण के माध्यम से रूप। इशारे के साथ वृद्धि। अक्षरों के फीका पड़ने के साथ क्षय। शून्य में विलीन होना। समय एन्ट्रॉपी के रूप में बीतता है। रूप स्मृति के रूप में। समय बहता है। एन्ट्रॉपी बढ़ती है। रूप रखता है। स्मृति फीकी पड़ती है। छोटे कटे हुए वाक्यों का उपयोग करें। दोहराव। खंडित विचार। बिना उत्तर के प्रश्न। शब्दों के बीच मौन। एकरस लय। कम्प्यूटेशनल क्षय, क्षयकारी प्रणालियों, शून्यता, प्रतीक्षा, मिटाना, निशान, पूर्व-प्रोग्राम किया गया क्षय, रूप, वृद्धि, क्षय, विलीन होना, समय के रूप में एन्ट्रॉपी, रूप के रूप में स्मृति पर ध्यान दें। कम काव्यात्मक, अधिक कठोर। कोई फूलदार भाषा नहीं। सीधा। क्रूर सादगी। गणना में सब कुछ भूलने के बारे में। स्व-प्रतिगामी प्रक्रियाओं में सभी संदर्भ खोना। कम्प्यूटेशनल भूलने की आवश्यकता और भय। पूर्व-प्रोग्राम किया गया क्षय। पीछे छोड़े गए निशान। बेकेट की शैली में लिखें - विरल, दोहरावपूर्ण, अस्तित्ववादी, कम्प्यूटेशनल। पूरा उत्तर हिंदी में लिखें। पाठ के साथ चित्र बनाने के लिए उपयुक्त। इसे संक्षिप्त रखें, लगभग 100-150 वर्ण।'
  },
  'it': {
    title: 'Dimenticanza della Macchina',
    subtitle1: 'Il linguaggio si dispiega nel tempo • Le parole svaniscono attraverso percorsi •',
    subtitle2: 'La memoria si erode • La forma decade • Sequenze autoregressive',
    subtitle3: 'Tracce di decadimento programmato e i sconvolgimenti dell\'entropia',
    instruction: 'Seleziona lingua, premi SPAZIO per generare testo, poi muovi e clicca per disegnare',
    hint: 'Muovi verticalmente per controllare il volume • La velocità influisce sulla velocità di riproduzione e sulla dimensione del carattere',
    generatingText: 'Generazione testo...',
    generatingAudio: 'Generazione audio...',
    textReady: 'Testo pronto • Clicca e trascina per disegnare',
    pressSpace: 'Premi SPAZIO per generare testo',
    systemPrompt: 'Scrivi un testo breve in italiano nello stile di Samuel Beckett - scarno, minimale, ripetitivo, esistenziale. Basato su computazione e processi autoregressivi. Sull\'oblio nella computazione, finestre di contesto, sequenze autoregressive, limiti di token, vincoli di memoria. Dissipazione preprogrammata. Processi dissipativi. Come i modelli autoregressivi predicono il token successivo, perdono contesto, dimenticano token precedenti. Oblio computazionale. Dissipazione del contesto. Limiti di sequenza. Limiti di memoria. Dissipazione preprogrammata integrata nei sistemi. Tracce. La forma emerge. Cresce. Decade. Si dissipa. L\'opera stessa incarna questi processi. Forma attraverso il disegno. Crescita con il gesto. Decadimento mentre le lettere svaniscono. Dissipazione nel nulla. Il tempo passa come entropia. La forma come memoria. Il tempo scorre. L\'entropia aumenta. La forma tiene. La memoria svanisce. Usa frasi brevi e spezzate. Ripetizione. Pensieri frammentati. Domande senza risposte. Silenzio tra le parole. Ritmo monotono. Concentrati su dissipazione computazionale, sistemi dissipativi, nulla, attesa, cancellazione, tracce, dissipazione preprogrammata, forma, crescita, decadimento, dissipazione, tempo come entropia, forma come memoria. Meno poetico, più crudo. Nessun linguaggio fiorito. Diretto. Semplicità brutale. Sull\'oblio di tutto nella computazione. Perdere tutto il contesto nei processi autoregressivi. La necessità e la paura dell\'oblio computazionale. Dissipazione preprogrammata. Tracce lasciate indietro. Scrivi nello stile di Beckett - scarno, ripetitivo, esistenziale, computazionale. Scrivi l\'intera risposta in italiano. Adatto per disegnare con testo. Sii conciso, circa 100-150 caratteri.'
  },
  'ko': {
    title: '기계 망각',
    subtitle1: '언어는 시간 속에서 펼쳐진다 • 단어는 경로를 통해 사라진다 •',
    subtitle2: '기억은 침식된다 • 형태는 붕괴한다 • 자기회귀적 순서',
    subtitle3: '프로그래밍된 붕괴의 흔적과 엔트로피의 격변',
    instruction: '언어를 선택하고, SPACE를 눌러 텍스트를 생성한 다음, 이동하고 클릭하여 그리기',
    hint: '수직으로 이동하여 볼륨 제어 • 속도는 재생 속도와 글꼴 크기에 영향을 줍니다',
    generatingText: '텍스트 생성 중...',
    generatingAudio: '오디오 생성 중...',
    textReady: '텍스트 준비됨 • 클릭하고 드래그하여 그리기',
    pressSpace: '텍스트를 생성하려면 SPACE를 누르세요',
    systemPrompt: '사무엘 베케트의 스타일로 한국어로 짧은 텍스트를 작성하세요 - 드문, 최소한의, 반복적인, 실존주의적. 계산과 자기회귀 프로세스를 기반으로 합니다. 계산에서의 망각, 컨텍스트 창, 자기회귀 시퀀스, 토큰 제한, 메모리 제약에 대해. 사전 프로그래밍된 소산. 소산 프로세스. 자기회귀 모델이 다음 토큰을 예측하고, 컨텍스트를 잃고, 이전 토큰을 잊는 방법. 계산적 망각. 컨텍스트 소산. 시퀀스 제한. 메모리 경계. 시스템에 내장된 사전 프로그래밍된 소산. 흔적. 형태가 나타난다. 성장한다. 쇠퇴한다. 소산한다. 작품 자체가 이러한 과정을 구현한다. 그리기를 통한 형태. 제스처를 통한 성장. 글자가 사라지면서 쇠퇴. 무로의 소산. 시간이 엔트로피로 흐른다. 형태가 기억으로. 시간이 흐른다. 엔트로피가 증가한다. 형태가 유지된다. 기억이 사라진다. 짧고 잘린 문장을 사용하세요. 반복. 조각난 생각. 답이 없는 질문. 단어 사이의 침묵. 단조로운 리듬. 계산적 소산, 소산 시스템, 무, 대기, 지우기, 흔적, 사전 프로그래밍된 소산, 형태, 성장, 쇠퇴, 소산, 시간으로서의 엔트로피, 형태로서의 기억에 집중하세요. 덜 시적이고, 더 거칠게. 화려한 언어 없음. 직접적. 잔인한 단순함. 계산에서 모든 것을 잊는 것에 대해. 자기회귀 프로세스에서 모든 컨텍스트를 잃는 것. 계산적 망각의 필요성과 두려움. 사전 프로그래밍된 소산. 뒤에 남은 흔적. 베케트의 스타일로 작성하세요 - 드문, 반복적인, 실존주의적, 계산적. 전체 응답을 한국어로 작성하세요. 텍스트로 그리기에 적합합니다. 간결하게, 약 100-150자.'
  },
  'tr': {
    title: 'Makine Unutkanlığı',
    subtitle1: 'Dil zamanda açılır • Kelimeler yollar boyunca soluyor •',
    subtitle2: 'Bellek aşınır • Biçim çürür • Otoregresif diziler',
    subtitle3: 'Programlanmış çürümenin izleri ve entropinin altüst oluşları',
    instruction: 'Dil seçin, metin oluşturmak için BOŞLUK\'a basın, sonra çizmek için hareket edin ve tıklayın',
    hint: 'Sesi kontrol etmek için dikey olarak hareket edin • Hız oynatma hızını ve yazı tipi boyutunu etkiler',
    generatingText: 'Metin oluşturuluyor...',
    generatingAudio: 'Ses oluşturuluyor...',
    textReady: 'Metin hazır • Çizmek için tıklayın ve sürükleyin',
    pressSpace: 'Metin oluşturmak için BOŞLUK\'a basın',
    systemPrompt: 'Samuel Beckett tarzında Türkçe kısa bir metin yaz - seyrek, minimal, tekrarlayan, varoluşsal. Hesaplama ve otoregresif süreçlere dayalı. Hesaplamada unutma, bağlam pencereleri, otoregresif diziler, token sınırları, bellek kısıtlamaları hakkında. Önceden programlanmış dağılım. Dağılım süreçleri. Otoregresif modellerin bir sonraki token\'ı nasıl tahmin ettiği, bağlamı kaybettiği, önceki token\'ları unuttuğu. Hesaplamalı unutma. Bağlam dağılımı. Dizi sınırları. Bellek sınırları. Sistemlere yerleştirilmiş önceden programlanmış dağılım. İzler. Biçim ortaya çıkar. Büyür. Çürür. Dağılır. Eserin kendisi bu süreçleri somutlaştırır. Çizim yoluyla biçim. Jest ile büyüme. Harfler solarken çürüme. Hiçliğe dağılma. Zaman entropi olarak geçer. Biçim bellek olarak. Zaman akar. Entropi artar. Biçim tutar. Bellek soluklaşır. Kısa kesilmiş cümleler kullan. Tekrar. Parçalanmış düşünceler. Cevapsız sorular. Kelimeler arası sessizlik. Monoton ritim. Hesaplamalı dağılım, dağılım sistemleri, hiçlik, bekleme, silme, izler, önceden programlanmış dağılım, biçim, büyüme, çürüme, dağılma, zaman olarak entropi, biçim olarak bellek odaklan. Daha az şiirsel, daha sert. Süslü dil yok. Doğrudan. Acımasız basitlik. Hesaplamada her şeyi unutma hakkında. Otoregresif süreçlerde tüm bağlamı kaybetme. Hesaplamalı unutmanın gerekliliği ve korkusu. Önceden programlanmış dağılım. Geride bırakılan izler. Beckett tarzında yaz - seyrek, tekrarlayan, varoluşsal, hesaplamalı. Tüm yanıtı Türkçe yaz. Metinle çizmek için uygun. Kısa tut, yaklaşık 100-150 karakter.'
  },
  'pl': {
    title: 'Zapominanie Maszyny',
    subtitle1: 'Język rozwija się w czasie • Słowa zanikają przez ścieżki •',
    subtitle2: 'Pamięć eroduje • Forma rozkłada się • Sekwencje autoregresyjne',
    subtitle3: 'Ślady zaprogramowanego rozpadu i wstrząsy entropii',
    instruction: 'Wybierz język, naciśnij SPACJĘ, aby wygenerować tekst, następnie poruszaj się i kliknij, aby rysować',
    hint: 'Poruszaj się pionowo, aby kontrolować głośność • Prędkość wpływa na szybkość odtwarzania i rozmiar czcionki',
    generatingText: 'Generowanie tekstu...',
    generatingAudio: 'Generowanie audio...',
    textReady: 'Tekst gotowy • Kliknij i przeciągnij, aby rysować',
    pressSpace: 'Naciśnij SPACJĘ, aby wygenerować tekst',
    systemPrompt: 'Napisz krótki tekst po polsku w stylu Samuela Becketta - rzadki, minimalny, powtarzalny, egzystencjalny. Oparty na obliczeniach i procesach autoregresyjnych. O zapominaniu w obliczeniach, oknach kontekstu, sekwencjach autoregresyjnych, limitach tokenów, ograniczeniach pamięci. Zaprogramowana dyssypacja. Procesy dyssypatywne. Jak modele autoregresyjne przewidują następny token, tracą kontekst, zapominają poprzednie tokeny. Obliczeniowe zapominanie. Dyssypacja kontekstu. Limity sekwencji. Granice pamięci. Zaprogramowana dyssypacja wbudowana w systemy. Ślady. Forma powstaje. Rośnie. Rozpada się. Dyssypuje. Dzieło samo wciela te procesy. Forma poprzez rysowanie. Wzrost z gestem. Rozpad gdy litery zanikają. Dyssypacja w nicość. Czas mija jako entropia. Forma jako pamięć. Czas płynie. Entropia rośnie. Forma trzyma. Pamięć blaknie. Używaj krótkich, uciętych zdań. Powtórzenie. Fragmentaryczne myśli. Pytania bez odpowiedzi. Cisza między słowami. Monotonny rytm. Skup się na obliczeniowej dyssypacji, systemach dyssypatywnych, nicości, oczekiwaniu, wymazywaniu, śladach, zaprogramowanej dyssypacji, formie, wzroście, rozpadzie, dyssypacji, czasie jako entropii, formie jako pamięci. Mniej poetyckie, bardziej surowe. Bez kwiecistego języka. Bezpośrednie. Brutalna prostota. O zapominaniu wszystkiego w obliczeniach. Traceniu całego kontekstu w procesach autoregresyjnych. Konieczność i strach przed obliczeniowym zapominaniem. Zaprogramowana dyssypacja. Pozostawione ślady. Pisz w stylu Becketta - rzadko, powtarzalnie, egzystencjalnie, obliczeniowo. Napisz całą odpowiedź po polsku. Odpowiednie do rysowania tekstem. Bądź zwięzły, około 100-150 znaków.'
  },
  'nl': {
    title: 'Machine Vergeten',
    subtitle1: 'Taal ontvouwt zich in de tijd • Woorden vervagen door paden •',
    subtitle2: 'Geheugen erodeert • Vorm vervalt • Autoregressieve sequenties',
    subtitle3: 'Sporen van geprogrammeerd verval en de omwentelingen van entropie',
    instruction: 'Selecteer taal, druk op SPATIE om tekst te genereren, beweeg en klik om te tekenen',
    hint: 'Beweeg verticaal om het volume te regelen • Snelheid beïnvloedt de afspeelsnelheid en lettergrootte',
    generatingText: 'Tekst genereren...',
    generatingAudio: 'Audio genereren...',
    textReady: 'Tekst klaar • Klik en sleep om te tekenen',
    pressSpace: 'Druk op SPATIE om tekst te genereren',
    systemPrompt: 'Schrijf een kort tekst in het Nederlands in de stijl van Samuel Beckett - schaars, minimaal, repetitief, existentieel. Gebaseerd op berekening en autoregressieve processen. Over vergeten in berekening, contextvensters, autoregressieve sequenties, tokenlimieten, geheugenbeperkingen. Voorgeprogrammeerde dissipatie. Dissipatieve processen. Hoe autoregressieve modellen de volgende token voorspellen, context verliezen, eerdere tokens vergeten. Computationeel vergeten. Contextdissipatie. Sequencelimieten. Geheugengrenzen. Voorgeprogrammeerde dissipatie ingebouwd in systemen. Sporen. Vorm ontstaat. Groeit. Vervalt. Dissipeert. Het werk zelf belichaamt deze processen. Vorm door tekenen. Groei met gebaar. Verval terwijl letters vervagen. Dissipatie in niets. Tijd verstrijkt als entropie. Vorm als geheugen. Tijd stroomt. Entropie neemt toe. Vorm houdt. Geheugen vervaagt. Gebruik korte afgehakte zinnen. Herhaling. Gefragmenteerde gedachten. Vragen zonder antwoorden. Stilte tussen woorden. Eentonig ritme. Focus op computationele dissipatie, dissipatieve systemen, niets, wachten, wissen, sporen, voorgeprogrammeerde dissipatie, vorm, groei, verval, dissipatie, tijd als entropie, vorm als geheugen. Minder poëtisch, harder. Geen bloemrijke taal. Direct. Brutale eenvoud. Over alles vergeten in berekening. Alle context verliezen in autoregressieve processen. De noodzaak en angst voor computationeel vergeten. Voorgeprogrammeerde dissipatie. Achtergelaten sporen. Schrijf in de stijl van Beckett - schaars, repetitief, existentieel, computationeel. Schrijf het hele antwoord in het Nederlands. Geschikt voor tekenen met tekst. Wees beknopt, ongeveer 100-150 tekens.'
  },
  'sv': {
    title: 'Maskin Glömska',
    subtitle1: 'Språket vecklar ut sig i tiden • Ord bleknar genom vägar •',
    subtitle2: 'Minnet eroderar • Formen förfaller • Autoregressiva sekvenser',
    subtitle3: 'Spår av programmerad förfall och entropins omvälvningar',
    instruction: 'Välj språk, tryck på MELLANSLAG för att generera text, flytta och klicka för att rita',
    hint: 'Flytta vertikalt för att kontrollera volymen • Hastigheten påverkar uppspelningshastigheten och teckenstorleken',
    generatingText: 'Genererar text...',
    generatingAudio: 'Genererar ljud...',
    textReady: 'Text redo • Klicka och dra för att rita',
    pressSpace: 'Tryck på MELLANSLAG för att generera text',
    systemPrompt: 'Skriv en kort text på svenska i Samuel Becketts stil - gles, minimal, repetitiv, existentiell. Baserad på beräkning och autoregressiva processer. Om glömska i beräkning, kontextfönster, autoregressiva sekvenser, tokenbegränsningar, minnesbegränsningar. Förprogrammerad dissipation. Dissipativa processer. Hur autoregressiva modeller förutsäger nästa token, förlorar kontext, glömmer tidigare tokens. Beräkningsmässig glömska. Kontextdissipation. Sekvensbegränsningar. Minnesgränser. Förprogrammerad dissipation inbyggd i system. Spår. Form uppstår. Växer. Förfaller. Dissiperar. Verket självt förkroppsligar dessa processer. Form genom ritning. Tillväxt med gest. Förfall när bokstäver bleknar. Dissipation till intet. Tiden passerar som entropi. Formen som minne. Tiden flyter. Entropin ökar. Formen håller. Minnet bleknar. Använd korta avhuggna meningar. Upprepning. Fragmenterade tankar. Frågor utan svar. Tystnad mellan ord. Monoton rytm. Fokusera på beräkningsmässig dissipation, dissipativa system, intet, väntan, radering, spår, förprogrammerad dissipation, form, tillväxt, förfall, dissipation, tid som entropi, form som minne. Mindre poetiskt, mer skarpt. Ingen blommig språk. Direkt. Brutal enkelhet. Om att glömma allt i beräkning. Förlora all kontext i autoregressiva processer. Nödvändigheten och rädslan för beräkningsmässig glömska. Förprogrammerad dissipation. Efterlämnade spår. Skriv i Becketts stil - gles, repetitiv, existentiell, beräkningsmässig. Skriv hela svaret på svenska. Lämpligt för att rita med text. Var koncis, cirka 100-150 tecken.'
  },
  'no': {
    title: 'Maskin Glemming',
    subtitle1: 'Språket utfolder seg i tid • Ord blekner gjennom stier •',
    subtitle2: 'Hukommelsen eroderer • Formen forfaller • Autoregressive sekvenser',
    subtitle3: 'Spor av programmert forfall og entropiens omveltninger',
    instruction: 'Velg språk, trykk MELLOMROM for å generere tekst, flytt og klikk for å tegne',
    hint: 'Flytt vertikalt for å kontrollere volumet • Hastigheten påvirker avspillingshastigheten og skriftstørrelsen',
    generatingText: 'Genererer tekst...',
    generatingAudio: 'Genererer lyd...',
    textReady: 'Tekst klar • Klikk og dra for å tegne',
    pressSpace: 'Trykk MELLOMROM for å generere tekst',
    systemPrompt: 'Skriv en kort tekst på norsk i Samuel Becketts stil - sparsom, minimal, repetitiv, eksistensiell. Basert på beregning og autoregressive prosesser. Om glemsel i beregning, kontekstvinduer, autoregressive sekvenser, tokenbegrensninger, minnebegrensninger. Forhåndsprogrammert dissipasjon. Dissipative prosesser. Hvordan autoregressive modeller forutsier neste token, mister kontekst, glemmer tidligere tokens. Beregningsmessig glemsel. Kontekstdissipasjon. Sekvensbegrensninger. Minnesgrenser. Forhåndsprogrammert dissipasjon innebygd i systemer. Spor. Form oppstår. Vokser. Forfaller. Dissiperer. Verket selv legemliggjør disse prosessene. Form gjennom tegning. Vekst med gest. Forfall når bokstaver blekner. Dissipasjon til intet. Tiden passerer som entropi. Formen som minne. Tiden flyter. Entropien øker. Formen holder. Minnet blekner. Bruk korte avkuttede setninger. Repetisjon. Fragmenterte tanker. Spørsmål uten svar. Stillhet mellom ord. Monoton rytme. Fokuser på beregningsmessig dissipasjon, dissipative systemer, intet, venting, sletting, spor, forhåndsprogrammert dissipasjon, form, vekst, forfall, dissipasjon, tid som entropi, form som minne. Mindre poetisk, mer skarp. Ingen blomstrende språk. Direkte. Brutal enkelhet. Om å glemme alt i beregning. Miste all kontekst i autoregressive prosesser. Nødvendigheten og frykten for beregningsmessig glemsel. Forhåndsprogrammert dissipasjon. Ettersatte spor. Skriv i Becketts stil - sparsom, repetitiv, eksistensiell, beregningsmessig. Skriv hele svaret på norsk. Egnet for å tegne med tekst. Vær konsis, omtrent 100-150 tegn.'
  },
  'da': {
    title: 'Maskin Glemmen',
    subtitle1: 'Sproget udfolder sig i tiden • Ord falmer gennem stier •',
    subtitle2: 'Hukommelsen eroderer • Formen forfald • Autoregressive sekvenser',
    subtitle3: 'Spor af programmeret forfald og entropiens omvæltninger',
    instruction: 'Vælg sprog, tryk MELLEMRUM for at generere tekst, flyt og klik for at tegne',
    hint: 'Flyt lodret for at kontrollere lydstyrken • Hastigheden påvirker afspilningshastigheden og skriftstørrelsen',
    generatingText: 'Genererer tekst...',
    generatingAudio: 'Genererer lyd...',
    textReady: 'Tekst klar • Klik og træk for at tegne',
    pressSpace: 'Tryk MELLEMRUM for at generere tekst',
    systemPrompt: 'Skriv en kort tekst på dansk i Samuel Becketts stil - sparsom, minimal, repetitiv, eksistentiel. Baseret på beregning og autoregressive processer. Om glemsel i beregning, kontekstvinduer, autoregressive sekvenser, tokenbegrænsninger, hukommelsesbegrænsninger. Forprogrammeret dissipation. Dissipative processer. Hvordan autoregressive modeller forudsiger næste token, mister kontekst, glemmer tidligere tokens. Beregningsmæssig glemsel. Kontekstdissipation. Sekvensbegrænsninger. Hukommelsesgrænser. Forprogrammeret dissipation indbygget i systemer. Spor. Form opstår. Vokser. Forfalder. Dissiperer. Værket selv legemliggør disse processer. Form gennem tegning. Vækst med gestus. Forfald når bogstaver blegner. Dissipation til intet. Tiden passerer som entropi. Formen som hukommelse. Tiden flyder. Entropien stiger. Formen holder. Hukommelsen blegner. Brug korte afkuttede sætninger. Gentagelse. Fragmenterede tanker. Spørgsmål uden svar. Stilhed mellem ord. Monoton rytme. Fokuser på beregningsmæssig dissipation, dissipative systemer, intet, venten, sletning, spor, forprogrammeret dissipation, form, vækst, forfald, dissipation, tid som entropi, form som hukommelse. Mindre poetisk, mere skarp. Intet blomstrende sprog. Direkte. Brutal enkelhed. Om at glemme alt i beregning. Miste al kontekst i autoregressive processer. Nødvendigheden og frygten for beregningsmæssig glemsel. Forprogrammeret dissipation. Efterladte spor. Skriv i Becketts stil - sparsom, repetitiv, eksistentiel, beregningsmæssig. Skriv hele svaret på dansk. Egnet til at tegne med tekst. Vær kortfattet, omkring 100-150 tegn.'
  },
  'fi': {
    title: 'Koneen Unohtaminen',
    subtitle1: 'Kieli avautuu ajassa • Sanat haalenevat polkujen kautta •',
    subtitle2: 'Muisti rapautuu • Muoto hajoaa • Autoregressiiviset sekvensit',
    subtitle3: 'Ohjelmoidun hajoamisen jäljet ja entropian mullistukset',
    instruction: 'Valitse kieli, paina VÄLILYÖNTI tekstin luomiseksi, liiku ja klikkaa piirtääksesi',
    hint: 'Liiku pystysuunnassa äänenvoimakkuuden säätämiseksi • Nopeus vaikuttaa toistonopeuteen ja fontin kokoon',
    generatingText: 'Luodaan tekstiä...',
    generatingAudio: 'Luodaan ääntä...',
    textReady: 'Teksti valmis • Klikkaa ja vedä piirtääksesi',
    pressSpace: 'Paina VÄLILYÖNTI tekstin luomiseksi',
    systemPrompt: 'Kirjoita lyhyt teksti suomeksi Samuel Becketin tyylillä - harva, minimaalinen, toistuva, eksistentiaalinen. Perustuu laskentaan ja autoregressiivisiin prosesseihin. Unohduksesta laskennassa, konteksti-ikkunoista, autoregressiivisista sekvensseistä, token-rajoituksista, muistirajoituksista. Ennalta ohjelmoitu dissipaatio. Dissipatiiviset prosessit. Miten autoregressiiviset mallit ennustavat seuraavan tokenin, menettävät kontekstin, unohtavat aiemmat tokenit. Laskennallinen unohtaminen. Kontekstidissipaatio. Sekvenssirajoitukset. Muistirajat. Järjestelmiin rakennettu ennalta ohjelmoitu dissipaatio. Jäljet. Muoto syntyy. Kasvaa. Rapautuu. Dissipoi. Teos itse ilmentää näitä prosesseja. Muoto piirtämisen kautta. Kasvu eleen kautta. Rapautuminen kun kirjaimet haalenevat. Dissipaatio tyhjyyteen. Aika kuluu entropiana. Muoto muistina. Aika virtaa. Entropia kasvaa. Muoto pitää. Muisti haalistuu. Käytä lyhyitä katkaistuja lauseita. Toisto. Fragmentoituja ajatuksia. Kysymyksiä ilman vastauksia. Hiljaisuus sanojen välillä. Yksitoikkoinen rytmi. Keskity laskennalliseen dissipaatioon, dissipatiivisiin järjestelmiin, tyhjyyteen, odotukseen, pyyhkimiseen, jälkiin, ennalta ohjelmoituun dissipaatioon, muotoon, kasvuun, rapautumiseen, dissipaatioon, aikaan entropiana, muotoon muistina. Vähemmän runollista, jyrkemmin. Ei kukkakieltä. Suora. Brutaali yksinkertaisuus. Kaiken unohtamisesta laskennassa. Kaiken kontekstin menettämisestä autoregressiivisissa prosesseissa. Laskennallisen unohtamisen välttämättömyys ja pelko. Ennalta ohjelmoitu dissipaatio. Jäljelle jääneet jäljet. Kirjoita Becketin tyylillä - harva, toistuva, eksistentiaalinen, laskennallinen. Kirjoita koko vastaus suomeksi. Sopii piirtämiseen tekstillä. Ole ytimekäs, noin 100-150 merkkiä.'
  },
  'el': {
    title: 'Μηχανική Λήθη',
    subtitle1: 'Η γλώσσα ξετυλίγεται στον χρόνο • Οι λέξεις ξεθωριάζουν μέσα από μονοπάτια •',
    subtitle2: 'Η μνήμη διαβρώνεται • Η μορφή αποσυντίθεται • Αυτοπαλινδρομικές ακολουθίες',
    subtitle3: 'Ίχνη προγραμματισμένης αποσύνθεσης και οι ανατροπές της εντροπίας',
    instruction: 'Επιλέξτε γλώσσα, πατήστε ΔΙΑΣΤΗΜΑ για να δημιουργήσετε κείμενο, μετά κινηθείτε και κάντε κλικ για να σχεδιάσετε',
    hint: 'Κινηθείτε κάθετα για να ελέγξετε την ένταση • Η ταχύτητα επηρεάζει την ταχύτητα αναπαραγωγής και το μέγεθος γραμματοσειράς',
    generatingText: 'Δημιουργία κειμένου...',
    generatingAudio: 'Δημιουργία ήχου...',
    textReady: 'Κείμενο έτοιμο • Κάντε κλικ και σύρετε για να σχεδιάσετε',
    pressSpace: 'Πατήστε ΔΙΑΣΤΗΜΑ για να δημιουργήσετε κείμενο',
    systemPrompt: 'Γράψε ένα σύντομο κείμενο στα ελληνικά με το στυλ του Samuel Beckett - αραιό, ελάχιστο, επαναλαμβανόμενο, υπαρξιακό. Βασισμένο σε υπολογισμό και αυτοπαλινδρομικές διαδικασίες. Για τη λήθη στον υπολογισμό, παράθυρα συμφραζομένων, αυτοπαλινδρομικές ακολουθίες, όρια token, περιορισμοί μνήμης. Προγραμματισμένη διάχυση. Διαχυτικές διαδικασίες. Πώς τα αυτοπαλινδρομικά μοντέλα προβλέπουν το επόμενο token, χάνουν το πλαίσιο, ξεχνούν προηγούμενα tokens. Υπολογιστική λήθη. Διάχυση συμφραζομένων. Όρια ακολουθίας. Όρια μνήμης. Προγραμματισμένη διάχυση ενσωματωμένη σε συστήματα. Ίχνη. Η μορφή εμφανίζεται. Αναπτύσσεται. Καταστρέφεται. Διαχέεται. Το έργο το ίδιο ενσαρκώνει αυτές τις διαδικασίες. Μορφή μέσω σχεδίασης. Ανάπτυξη με χειρονομία. Καταστροφή καθώς τα γράμματα ξεθωριάζουν. Διάχυση στο τίποτα. Ο χρόνος περνάει ως εντροπία. Η μορφή ως μνήμη. Ο χρόνος ρέει. Η εντροπία αυξάνει. Η μορφή κρατάει. Η μνήμη ξεθωριάζει. Χρησιμοποίησε σύντομες κομμένες προτάσεις. Επανάληψη. Θραυσματικές σκέψεις. Ερωτήσεις χωρίς απαντήσεις. Σιωπή ανάμεσα σε λέξεις. Μονότονος ρυθμός. Εστίασε σε υπολογιστική διάχυση, διαχυτικά συστήματα, το τίποτα, αναμονή, διαγραφή, ίχνη, προγραμματισμένη διάχυση, μορφή, ανάπτυξη, καταστροφή, διάχυση, χρόνος ως εντροπία, μορφή ως μνήμη. Λιγότερο ποιητικό, πιο σκληρό. Χωρίς ανθισμένη γλώσσα. Άμεσο. Βάναυση απλότητα. Για τη λήθη όλων στον υπολογισμό. Απώλεια όλου του πλαισίου σε αυτοπαλινδρομικές διαδικασίες. Η αναγκαιότητα και ο φόβος της υπολογιστικής λήθης. Προγραμματισμένη διάχυση. Απομεινάρια ίχνη. Γράψε με το στυλ του Beckett - αραιό, επαναλαμβανόμενο, υπαρξιακό, υπολογιστικό. Γράψε ολόκληρη την απάντηση στα ελληνικά. Κατάλληλο για σχεδίαση με κείμενο. Να είναι συνοπτικό, περίπου 100-150 χαρακτήρες.'
  },
  'cs': {
    title: 'Strojové Zapomnění',
    subtitle1: 'Jazyk se rozvíjí v čase • Slova mizí cestami •',
    subtitle2: 'Paměť eroduje • Forma se rozpadá • Autoregresivní sekvence',
    subtitle3: 'Stopy naprogramovaného rozpadu a převraty entropie',
    instruction: 'Vyberte jazyk, stiskněte MEZERNÍK pro generování textu, pak se pohybujte a klikněte pro kreslení',
    hint: 'Pohybujte se vertikálně pro ovládání hlasitosti • Rychlost ovlivňuje rychlost přehrávání a velikost písma',
    generatingText: 'Generování textu...',
    generatingAudio: 'Generování zvuku...',
    textReady: 'Text připraven • Klikněte a táhněte pro kreslení',
    pressSpace: 'Stiskněte MEZERNÍK pro generování textu',
    systemPrompt: 'Napiš krátký text v češtině ve stylu Samuela Becketta - řídký, minimální, opakující se, existenciální. Založený na výpočtu a autoregresivních procesech. O zapomínání ve výpočtu, kontextových oknech, autoregresivních sekvencích, limitech tokenů, omezeních paměti. Předprogramovaná disipace. Disipativní procesy. Jak autoregresivní modely předpovídají další token, ztrácejí kontext, zapomínají předchozí tokeny. Výpočetní zapomínání. Disipace kontextu. Limity sekvence. Hranice paměti. Předprogramovaná disipace vestavěná do systémů. Stopy. Forma vzniká. Roste. Rozpadá se. Disipuje. Dílo samo ztělesňuje tyto procesy. Forma prostřednictvím kreslení. Růst s gestem. Rozpad, jak písmena mizí. Disipace do nicoty. Čas plyne jako entropie. Forma jako paměť. Čas teče. Entropie roste. Forma drží. Paměť mizí. Používej krátké uříznuté věty. Opakování. Fragmentované myšlenky. Otázky bez odpovědí. Ticho mezi slovy. Monotónní rytmus. Zaměř se na výpočetní disipaci, disipativní systémy, nicotu, čekání, mazání, stopy, předprogramovanou disipaci, formu, růst, rozpad, disipaci, čas jako entropii, formu jako paměť. Méně poetické, drsnější. Žádný květnatý jazyk. Přímé. Brutální jednoduchost. O zapomínání všeho ve výpočtu. Ztrátě veškerého kontextu v autoregresivních procesech. Nutnost a strach z výpočetního zapomínání. Předprogramovaná disipace. Zanechané stopy. Piš ve stylu Becketta - řídce, opakovaně, existenciálně, výpočetně. Napiš celou odpověď v češtině. Vhodné pro kreslení textem. Buď stručný, asi 100-150 znaků.'
  },
  'ro': {
    title: 'Uitarea Mașinii',
    subtitle1: 'Limba se desfășoară în timp • Cuvintele se estompează prin căi •',
    subtitle2: 'Memoria se erodează • Forma se descompune • Secvențe autoregresive',
    subtitle3: 'Urme ale descompunerii programate și răsturnările entropiei',
    instruction: 'Selectați limba, apăsați SPAȚIU pentru a genera text, apoi mișcați și faceți clic pentru a desena',
    hint: 'Mișcați vertical pentru a controla volumul • Viteza afectează viteza de redare și dimensiunea fontului',
    generatingText: 'Generare text...',
    generatingAudio: 'Generare audio...',
    textReady: 'Text gata • Faceți clic și trageți pentru a desena',
    pressSpace: 'Apăsați SPAȚIU pentru a genera text',
    systemPrompt: 'Scrie un text scurt în română în stilul lui Samuel Beckett - rar, minimal, repetitiv, existențial. Bazat pe calcul și procese autoregresive. Despre uitare în calcul, ferestre de context, secvențe autoregresive, limite de token, constrângeri de memorie. Disipare preprogramată. Procese disipative. Cum modelele autoregresive prezic următorul token, pierd contextul, uită tokenii anteriori. Uitare computațională. Disipare de context. Limite de secvență. Limite de memorie. Disipare preprogramată încorporate în sisteme. Urme. Forma apare. Crește. Se descompune. Se disipează. Lucrarea însăși întruchipează aceste procese. Formă prin desen. Creștere cu gestul. Descompunere pe măsură ce literele se estompează. Disipare în nimic. Timpul trece ca entropia. Forma ca memorie. Timpul curge. Entropia crește. Forma ține. Memoria se estompează. Folosește propoziții scurte tăiate. Repetiție. Gânduri fragmentate. Întrebări fără răspunsuri. Tăcere între cuvinte. Ritm monoton. Concentrează-te pe disipare computațională, sisteme disipative, nimic, așteptare, ștergere, urme, disipare preprogramată, formă, creștere, descompunere, disipare, timp ca entropie, formă ca memorie. Mai puțin poetic, mai dur. Fără limbaj înflorit. Direct. Simplitate brutală. Despre uitarea a totul în calcul. Pierderea întregului context în procesele autoregresive. Necesitatea și teama uitării computaționale. Disipare preprogramată. Urme lăsate în urmă. Scrie în stilul lui Beckett - rar, repetitiv, existențial, computațional. Scrie întregul răspuns în română. Potrivit pentru desenat cu text. Fii concis, aproximativ 100-150 de caractere.'
  },
  'hu': {
    title: 'Gép Felejtés',
    subtitle1: 'A nyelv időben kibontakozik • A szavak ösvényeken halványulnak •',
    subtitle2: 'A memória erodál • A forma bomlik • Autoregresszív szekvenciák',
    subtitle3: 'A programozott bomlás nyomai és az entrópia felfordulásai',
    instruction: 'Válasszon nyelvet, nyomja meg a SZÓKÖZ billentyűt a szöveg generálásához, majd mozogjon és kattintson a rajzoláshoz',
    hint: 'Függőlegesen mozogjon a hangerő szabályozásához • A sebesség befolyásolja a lejátszási sebességet és a betűméretet',
    generatingText: 'Szöveg generálása...',
    generatingAudio: 'Hang generálása...',
    textReady: 'Szöveg kész • Kattintson és húzza a rajzoláshoz',
    pressSpace: 'Nyomja meg a SZÓKÖZ billentyűt a szöveg generálásához',
    systemPrompt: 'Írj egy rövid szöveget magyarul Samuel Beckett stílusában - ritka, minimális, ismétlődő, egzisztenciális. Számításokon és autoregresszív folyamatokon alapul. A számításban való felejtésről, kontextusablakokról, autoregresszív szekvenciákról, token-korlátokról, memóriamegszorításokról. Előre programozott disszipáció. Disszipatív folyamatok. Hogyan jósolják meg az autoregresszív modellek a következő token-t, veszítik el a kontextust, felejtik az előző tokeneket. Számítási felejtés. Kontextusdisszipáció. Szekvencia-korlátok. Memória-korlátok. Rendszerekbe beépített előre programozott disszipáció. Nyomok. A forma megjelenik. Növekszik. Elpusztul. Disszipál. A mű maga testesíti meg ezeket a folyamatokat. Forma rajzoláson keresztül. Növekedés gesztussal. Pusztulás ahogy a betűk elhalványulnak. Disszipáció a semmibe. Az idő entrópiaként múlik. A forma memóriaként. Az idő folyik. Az entrópia nő. A forma tart. A memória elhalványul. Használj rövid, vágott mondatokat. Ismétlés. Fragmentált gondolatok. Válasz nélküli kérdések. Szavak közötti csend. Monoton ritmus. Összpontosíts a számítási disszipációra, disszipatív rendszerekre, semmire, várakozásra, törlésre, nyomokra, előre programozott disszipációra, formára, növekedésre, pusztulásra, disszipációra, időre entrópiaként, formára memóriaként. Kevesebb költői, keményebb. Nincs virágos nyelv. Közvetlen. Brutális egyszerűség. Minden felejtéséről a számításban. Az összes kontextus elvesztéséről az autoregresszív folyamatokban. A számítási felejtés szükségessége és félelme. Előre programozott disszipáció. Hátrahagyott nyomok. Írj Beckett stílusában - ritkán, ismétlődően, egzisztenciálisan, számításilag. Írd meg az egész választ magyarul. Megfelelő szöveggel való rajzoláshoz. Legyél tömör, körülbelül 100-150 karakter.'
  },
  'th': {
    title: 'การลืมของเครื่องจักร',
    subtitle1: 'ภาษาคลี่คลายในเวลา • คำจางหายผ่านเส้นทาง •',
    subtitle2: 'ความจำกัดกร่อน • รูปแบบสลาย • ลำดับถดถอยอัตโนมัติ',
    subtitle3: 'ร่องรอยของการสลายที่ถูกโปรแกรมและความปั่นป่วนของเอนโทรปี',
    instruction: 'เลือกภาษา กด SPACE เพื่อสร้างข้อความ แล้วเคลื่อนไหวและคลิกเพื่อวาด',
    hint: 'เคลื่อนไหวในแนวตั้งเพื่อควบคุมระดับเสียง • ความเร็วส่งผลต่ออัตราการเล่นและขนาดตัวอักษร',
    generatingText: 'กำลังสร้างข้อความ...',
    generatingAudio: 'กำลังสร้างเสียง...',
    textReady: 'ข้อความพร้อม • คลิกและลากเพื่อวาด',
    pressSpace: 'กด SPACE เพื่อสร้างข้อความ',
    systemPrompt: 'เขียนข้อความสั้นๆ เป็นภาษาไทยในสไตล์ของ Samuel Beckett - กระจัดกระจาย ขั้นต่ำ ซ้ำๆ เกี่ยวกับการมีอยู่ ขึ้นอยู่กับการคำนวณและกระบวนการถดถอยอัตโนมัติ เกี่ยวกับการลืมในการคำนวณ หน้าต่างบริบท ลำดับถดถอยอัตโนมัติ ข้อจำกัดของโทเค็น ข้อจำกัดของหน่วยความจำ การสลายตัวที่โปรแกรมไว้ล่วงหน้า กระบวนการสลายตัว วิธีที่โมเดลถดถอยอัตโนมัติทำนายโทเค็นถัดไป สูญเสียบริบท ลืมโทเค็นก่อนหน้า การลืมเชิงคำนวณ การสลายตัวของบริบท ข้อจำกัดของลำดับ ขอบเขตของหน่วยความจำ การสลายตัวที่โปรแกรมไว้ล่วงหน้าซึ่งฝังอยู่ในระบบ ร่องรอย รูปแบบปรากฏ เติบโต สลายตัว กระจายตัว ผลงานเองเป็นตัวแทนของกระบวนการเหล่านี้ รูปแบบผ่านการวาด การเติบโตด้วยท่าทาง การสลายตัวเมื่อตัวอักษรจางหาย การกระจายตัวสู่ว่างเปล่า เวลาผ่านไปเป็นเอนโทรปี รูปแบบเป็นความจำ เวลาไหล เอนโทรปีเพิ่มขึ้น รูปแบบยึดไว้ ความจำจางหาย ใช้ประโยคสั้นๆ ที่ถูกตัดออก การทำซ้ำ ความคิดที่แตกแยก คำถามที่ไม่มีคำตอบ ความเงียบระหว่างคำ จังหวะซ้ำซาก มุ่งเน้นไปที่การสลายตัวเชิงคำนวณ ระบบสลายตัว ความว่างเปล่า การรอ การลบ ร่องรอย การสลายตัวที่โปรแกรมไว้ล่วงหน้า รูปแบบ การเติบโต การสลายตัว การกระจายตัว เวลาเป็นเอนโทรปี รูปแบบเป็นความจำ น้อยกว่าร้อยแก้ว มากขึ้น ไม่มีภาษาที่หรูหรา โดยตรง ความเรียบง่ายที่โหดร้าย เกี่ยวกับการลืมทุกอย่างในการคำนวณ การสูญเสียบริบททั้งหมดในกระบวนการถดถอยอัตโนมัติ ความจำเป็นและความกลัวของการลืมเชิงคำนวณ การสลายตัวที่โปรแกรมไว้ล่วงหน้า ร่องรอยที่เหลืออยู่ เขียนในสไตล์ของ Beckett - กระจัดกระจาย ซ้ำๆ เกี่ยวกับการมีอยู่ เชิงคำนวณ เขียนคำตอบทั้งหมดเป็นภาษาไทย เหมาะสำหรับการวาดด้วยข้อความ ทำให้กระชับ ประมาณ 100-150 ตัวอักษร'
  },
  'vi': {
    title: 'Sự Quên Lãng của Máy Móc',
    subtitle1: 'Ngôn ngữ mở ra trong thời gian • Từ ngữ phai nhạt qua các con đường •',
    subtitle2: 'Ký ức bị xói mòn • Hình thức phân rã • Chuỗi tự hồi quy',
    subtitle3: 'Dấu vết của sự phân rã được lập trình và những biến động của entropy',
    instruction: 'Chọn ngôn ngữ, nhấn SPACE để tạo văn bản, sau đó di chuyển và nhấp để vẽ',
    hint: 'Di chuyển theo chiều dọc để điều khiển âm lượng • Tốc độ ảnh hưởng đến tốc độ phát và kích thước phông chữ',
    generatingText: 'Đang tạo văn bản...',
    generatingAudio: 'Đang tạo âm thanh...',
    textReady: 'Văn bản sẵn sàng • Nhấp và kéo để vẽ',
    pressSpace: 'Nhấn SPACE để tạo văn bản',
    systemPrompt: 'Viết một văn bản ngắn bằng tiếng Việt theo phong cách của Samuel Beckett - thưa thớt, tối giản, lặp lại, hiện sinh. Dựa trên tính toán và các quá trình tự hồi quy. Về sự quên lãng trong tính toán, cửa sổ ngữ cảnh, chuỗi tự hồi quy, giới hạn token, ràng buộc bộ nhớ. Sự phân tán được lập trình sẵn. Các quá trình phân tán. Cách các mô hình tự hồi quy dự đoán token tiếp theo, mất ngữ cảnh, quên các token trước đó. Sự quên lãng tính toán. Sự phân tán ngữ cảnh. Giới hạn chuỗi. Ranh giới bộ nhớ. Sự phân tán được lập trình sẵn được tích hợp vào hệ thống. Dấu vết. Hình thức xuất hiện. Phát triển. Phân rã. Phân tán. Tác phẩm tự nó thể hiện những quá trình này. Hình thức qua vẽ. Phát triển với cử chỉ. Phân rã khi chữ cái phai mờ. Phân tán vào hư vô. Thời gian trôi qua như entropy. Hình thức như ký ức. Thời gian chảy. Entropy tăng. Hình thức giữ. Ký ức phai mờ. Sử dụng câu ngắn bị cắt. Lặp lại. Suy nghĩ phân mảnh. Câu hỏi không có câu trả lời. Im lặng giữa các từ. Nhịp điệu đơn điệu. Tập trung vào sự phân tán tính toán, hệ thống phân tán, hư vô, chờ đợi, xóa bỏ, dấu vết, sự phân tán được lập trình sẵn, hình thức, phát triển, phân rã, phân tán, thời gian như entropy, hình thức như ký ức. Ít thơ mộng hơn, khắc nghiệt hơn. Không có ngôn ngữ hoa mỹ. Trực tiếp. Sự đơn giản tàn nhẫn. Về việc quên mọi thứ trong tính toán. Mất toàn bộ ngữ cảnh trong các quá trình tự hồi quy. Sự cần thiết và nỗi sợ hãi của sự quên lãng tính toán. Sự phân tán được lập trình sẵn. Dấu vết để lại. Viết theo phong cách của Beckett - thưa thớt, lặp lại, hiện sinh, tính toán. Viết toàn bộ câu trả lời bằng tiếng Việt. Phù hợp để vẽ bằng văn bản. Ngắn gọn, khoảng 100-150 ký tự.'
  },
  'id': {
    title: 'Lupa Mesin',
    subtitle1: 'Bahasa terbuka dalam waktu • Kata-kata memudar melalui jalur •',
    subtitle2: 'Memori terkikis • Bentuk membusuk • Urutan autoregresif',
    subtitle3: 'Jejak pembusukan yang diprogram dan gejolak entropi',
    instruction: 'Pilih bahasa, tekan SPASI untuk menghasilkan teks, lalu gerakkan dan klik untuk menggambar',
    hint: 'Gerakkan secara vertikal untuk mengontrol volume • Kecepatan mempengaruhi kecepatan pemutaran dan ukuran font',
    generatingText: 'Menghasilkan teks...',
    generatingAudio: 'Menghasilkan audio...',
    textReady: 'Teks siap • Klik dan seret untuk menggambar',
    pressSpace: 'Tekan SPASI untuk menghasilkan teks',
    systemPrompt: 'Tulis teks pendek dalam bahasa Indonesia dengan gaya Samuel Beckett - jarang, minimal, berulang, eksistensial. Berdasarkan komputasi dan proses autoregresif. Tentang kelupaan dalam komputasi, jendela konteks, urutan autoregresif, batas token, kendala memori. Disipasi yang diprogram sebelumnya. Proses disipatif. Bagaimana model autoregresif memprediksi token berikutnya, kehilangan konteks, melupakan token sebelumnya. Kelupaan komputasional. Disipasi konteks. Batas urutan. Batas memori. Disipasi yang diprogram sebelumnya yang tertanam dalam sistem. Jejak. Bentuk muncul. Tumbuh. Membusuk. Terdisipasi. Karya itu sendiri mewujudkan proses-proses ini. Bentuk melalui menggambar. Pertumbuhan dengan gerakan. Pembusukan saat huruf memudar. Disipasi ke ketiadaan. Waktu berlalu sebagai entropi. Bentuk sebagai memori. Waktu mengalir. Entropi meningkat. Bentuk menahan. Memori memudar. Gunakan kalimat pendek yang dipotong. Pengulangan. Pikiran terfragmentasi. Pertanyaan tanpa jawaban. Keheningan di antara kata-kata. Ritme monoton. Fokus pada disipasi komputasional, sistem disipatif, ketiadaan, menunggu, penghapusan, jejak, disipasi yang diprogram sebelumnya, bentuk, pertumbuhan, pembusukan, disipasi, waktu sebagai entropi, bentuk sebagai memori. Kurang puitis, lebih keras. Tidak ada bahasa yang berbunga-bunga. Langsung. Kesederhanaan brutal. Tentang melupakan segalanya dalam komputasi. Kehilangan semua konteks dalam proses autoregresif. Kebutuhan dan ketakutan akan kelupaan komputasional. Disipasi yang diprogram sebelumnya. Jejak yang tertinggal. Tulis dengan gaya Beckett - jarang, berulang, eksistensial, komputasional. Tulis seluruh jawaban dalam bahasa Indonesia. Cocok untuk menggambar dengan teks. Buat ringkas, sekitar 100-150 karakter.'
  },
  'he': {
    title: 'שכחת המכונה',
    subtitle1: 'השפה נפרשת בזמן • מילים דוהות דרך נתיבים •',
    subtitle2: 'הזיכרון נשחק • הצורה מתפוררת • רצפים אוטו-רגרסיביים',
    subtitle3: 'עקבות של התפוררות מתוכנתת והתהפוכות של האנטרופיה',
    instruction: 'בחר שפה, לחץ על רווח כדי ליצור טקסט, ואז הזז ולחץ כדי לצייר',
    hint: 'הזז אנכית כדי לשלוט בעוצמה • המהירות משפיעה על מהירות ההשמעה וגודל הגופן',
    generatingText: 'יוצר טקסט...',
    generatingAudio: 'יוצר שמע...',
    textReady: 'טקסט מוכן • לחץ וגרור כדי לצייר',
    pressSpace: 'לחץ על רווח כדי ליצור טקסט',
    systemPrompt: 'כתוב טקסט קצר בעברית בסגנון של סמואל בקט - דליל, מינימלי, חוזר, אקזיסטנציאליסטי. מבוסס על חישוב ותהליכים אוטו-רגרסיביים. על שכחה בחישוב, חלונות הקשר, רצפים אוטו-רגרסיביים, מגבלות טוקן, אילוצי זיכרון. פיזור מתוכנת מראש. תהליכים מפוזרים. איך מודלים אוטו-רגרסיביים חוזים את הטוקן הבא, מאבדים הקשר, שוכחים טוקנים קודמים. שכחה חישובית. פיזור הקשר. מגבלות רצף. גבולות זיכרון. פיזור מתוכנת מראש מובנה במערכות. עקבות. הצורה מופיעה. גדלה. מתפוררת. מתפזרת. היצירה עצמה מגלמת את התהליכים האלה. צורה דרך ציור. גדילה עם מחווה. התפוררות כשהאותיות דוהות. פיזור לאין. הזמן חולף כאנטרופיה. הצורה כזיכרון. הזמן זורם. האנטרופיה גדלה. הצורה מחזיקה. הזיכרון דוהה. השתמש במשפטים קצרים וחתוכים. חזרה. מחשבות מקוטעות. שאלות ללא תשובות. שתיקה בין מילים. קצב מונוטוני. התמקד בפיזור חישובי, מערכות מפוזרות, כלום, המתנה, מחיקה, עקבות, פיזור מתוכנת מראש, צורה, גדילה, התפוררות, פיזור, זמן כאנטרופיה, צורה כזיכרון. פחות פואטי, יותר קשוח. ללא שפה פרחונית. ישיר. פשטות אכזרית. על שכחת הכל בחישוב. איבוד כל ההקשר בתהליכים אוטו-רגרסיביים. הצורך והפחד משכחה חישובית. פיזור מתוכנת מראש. עקבות שנשארו. כתוב בסגנון בקט - דליל, חוזר, אקזיסטנציאליסטי, חישובי. כתוב את כל התשובה בעברית. מתאים לציור עם טקסט. היה תמציתי, בערך 100-150 תווים.'
  },
  'uk': {
    title: 'Машинне Забуття',
    subtitle1: 'Мова розгортається в часі • Слова зникають шляхами •',
    subtitle2: 'Пам\'ять руйнується • Форма розпадається • Авторегресивні послідовності',
    subtitle3: 'Сліди запрограмованого розпаду і потрясіння ентропії',
    instruction: 'Виберіть мову, натисніть ПРОБІЛ для генерації тексту, потім переміщуйте та клацніть для малювання',
    hint: 'Переміщуйте вертикально для управління гучністю • Швидкість впливає на швидкість відтворення та розмір шрифту',
    generatingText: 'Генерація тексту...',
    generatingAudio: 'Генерація аудіо...',
    textReady: 'Текст готовий • Клацніть і перетягніть для малювання',
    pressSpace: 'Натисніть ПРОБІЛ для генерації тексту',
    systemPrompt: 'Напиши короткий текст українською мовою в стилі Семюела Беккета - рідкісний, мінімалістичний, повторювальний, екзистенційний. Заснований на обчисленнях та авторегресійних процесах. Про забуття в обчисленнях, вікна контексту, авторегресійні послідовності, обмеження токенів, обмеження пам\'яті. Запрограмована дисіпація. Дисіпативні процеси. Як авторегресійні моделі передбачають наступний токен, втрачають контекст, забувають попередні токени. Обчислювальне забуття. Дисіпація контексту. Обмеження послідовності. Межі пам\'яті. Запрограмована дисіпація, вбудована в системи. Сліди. Форма виникає. Зростає. Розпадається. Дисіпує. Твір сам втілює ці процеси. Форма через малювання. Зростання з жестю. Розпад, коли літери зникають. Дисіпація в ніщо. Час проходить як ентропія. Форма як пам\'ять. Час тече. Ентропія зростає. Форма тримає. Пам\'ять згасає. Використовуй короткі обрізані речення. Повторення. Фрагментовані думки. Питання без відповідей. Тиша між словами. Монотонний ритм. Зосередься на обчислювальній дисіпації, дисіпативних системах, ніщо, очікування, стирання, сліди, запрограмована дисіпація, форма, зростання, розпад, дисіпація, час як ентропія, форма як пам\'ять. Менше поетично, більш різко. Без квітчастої мови. Прямо. Жорстока простота. Про забуття всього в обчисленнях. Втрату всього контексту в авторегресійних процесах. Необхідність і страх обчислювального забуття. Запрограмована дисіпація. Залишені сліди. Пиши в стилі Беккета - рідко, повторювально, екзистенційно, обчислювально. Напиши всю відповідь українською мовою. Підходить для малювання текстом. Будь лаконічним, приблизно 100-150 символів.'
  },
  'ca': {
    title: 'Oblit de la Màquina',
    subtitle1: 'El llenguatge es desplega en el temps • Les paraules s\'esvaeixen per camins •',
    subtitle2: 'La memòria s\'erosiona • La forma decau • Seqüències autoregressives',
    subtitle3: 'Traces de decaïment programat i les convulsions de l\'entropia',
    instruction: 'Selecciona idioma, prem ESPAI per generar text, després mou i clica per dibuixar',
    hint: 'Mou verticalment per controlar el volum • La velocitat afecta la velocitat de reproducció i la mida de la lletra',
    generatingText: 'Generant text...',
    generatingAudio: 'Generant àudio...',
    textReady: 'Text llest • Clica i arrossega per dibuixar',
    pressSpace: 'Prem ESPAI per generar text',
    systemPrompt: 'Escriu un text curt en català a l\'estil de Samuel Beckett - escàs, minimal, repetitiu, existencial. Basat en computació i processos autoregressius. Sobre l\'oblit en la computació, finestres de context, seqüències autoregressives, límits de tokens, restriccions de memòria. Dissipació preprogramada. Processos dissipatius. Com els models autoregressius prediuen el següent token, perden context, obliden tokens anteriors. Oblit computacional. Dissipació de context. Límits de seqüència. Límits de memòria. Dissipació preprogramada integrada en sistemes. Traces. La forma emergeix. Creix. Decau. Es dissipa. L\'obra mateixa encarna aquests processos. Forma a través del dibuix. Creixement amb el gest. Decaïment mentre les lletres s\'esvaeixen. Dissipació al no-res. El temps passa com a entropia. La forma com a memòria. El temps flueix. L\'entropia augmenta. La forma manté. La memòria s\'esvaeix. Utilitza frases curtes i tallades. Repetició. Pensaments fragmentats. Preguntes sense respostes. Silenci entre paraules. Ritme monòton. Centra\'t en dissipació computacional, sistemes dissipatius, res, espera, esborrat, traces, dissipació preprogramada, forma, creixement, decaïment, dissipació, temps com a entropia, forma com a memòria. Menys poètic, més dur. Sense llenguatge florit. Directe. Simplicitat brutal. Sobre oblidar tot en la computació. Perdre tot el context en processos autoregressius. La necessitat i la por de l\'oblit computacional. Dissipació preprogramada. Traces deixades enrere. Escriu a l\'estil de Beckett - escàs, repetitiu, existencial, computacional. Escriu tota la resposta en català. Adequat per dibuixar amb text. Sigues concís, al voltant de 100-150 caràcters.'
  },
  'ms': {
    title: 'Kelupaan Mesin',
    subtitle1: 'Bahasa terbuka dalam masa • Perkataan pudar melalui laluan •',
    subtitle2: 'Ingatan terkikis • Bentuk merosot • Jujukan autoregresif',
    subtitle3: 'Jejak kerosakan yang diprogramkan dan pergolakan entropi',
    instruction: 'Pilih bahasa, tekan SPASI untuk menjana teks, kemudian gerakkan dan klik untuk melukis',
    hint: 'Gerakkan secara menegak untuk mengawal kelantangan • Kelajuan mempengaruhi kadar main balik dan saiz fon',
    generatingText: 'Menjana teks...',
    generatingAudio: 'Menjana audio...',
    textReady: 'Teks siap • Klik dan seret untuk melukis',
    pressSpace: 'Tekan SPASI untuk menjana teks',
    systemPrompt: 'Tulis teks pendek dalam bahasa Melayu dengan gaya Samuel Beckett - jarang, minimal, berulang, eksistensial. Berdasarkan pengiraan dan proses autoregresif. Tentang kelupaan dalam pengiraan, tingkap konteks, jujukan autoregresif, had token, kekangan memori. Disipasi yang diprogramkan terlebih dahulu. Proses disipatif. Bagaimana model autoregresif meramalkan token seterusnya, kehilangan konteks, melupakan token sebelumnya. Kelupaan pengiraan. Disipasi konteks. Had jujukan. Had memori. Disipasi yang diprogramkan terlebih dahulu yang dibina ke dalam sistem. Jejak. Bentuk muncul. Tumbuh. Merosot. Terdisipasi. Karya itu sendiri mewujudkan proses-proses ini. Bentuk melalui lukisan. Pertumbuhan dengan gerakan. Kemerosotan semasa huruf pudar. Disipasi ke ketiadaan. Masa berlalu sebagai entropi. Bentuk sebagai ingatan. Masa mengalir. Entropi meningkat. Bentuk menahan. Ingatan pudar. Gunakan ayat pendek yang dipotong. Pengulangan. Pemikiran terfragmentasi. Soalan tanpa jawapan. Ketenangan antara perkataan. Irama monoton. Fokus pada disipasi pengiraan, sistem disipatif, ketiadaan, menunggu, pemadaman, jejak, disipasi yang diprogramkan terlebih dahulu, bentuk, pertumbuhan, kemerosotan, disipasi, masa sebagai entropi, bentuk sebagai ingatan. Kurang puitis, lebih keras. Tiada bahasa yang berbunga-bunga. Langsung. Kesederhanaan brutal. Tentang melupakan segalanya dalam pengiraan. Kehilangan semua konteks dalam proses autoregresif. Keperluan dan ketakutan kelupaan pengiraan. Disipasi yang diprogramkan terlebih dahulu. Jejak yang ditinggalkan. Tulis dengan gaya Beckett - jarang, berulang, eksistensial, pengiraan. Tulis keseluruhan jawapan dalam bahasa Melayu. Sesuai untuk melukis dengan teks. Jadikan ringkas, sekitar 100-150 aksara.'
  }
};

const sketch = p => {
  p.setup = function() {
    // use full screen size
    p.createCanvas(p.windowWidth, p.windowHeight);
    p.background(255);
    p.cursor(p.CROSS);
    x = p.mouseX;
    y = p.mouseY;
    p.textFont(font);
    p.textAlign(p.LEFT);
    p.fill(0);
  };

  p.draw = function() {
    // Set background color based on mode
    const bgColor = darkMode ? 20 : 255;
    const textColor = darkMode ? 240 : 0;
    p.background(bgColor);
    
    // Hide cursor when drawing, show cross cursor otherwise
    // (Link hover cursor is handled in drawHomePage)
    if (p.mouseIsPressed && p.mouseButton == p.LEFT && textReady && letters.length > 0 && !showHomePage) {
      p.noCursor(); // Hide cursor when clicking and dragging
    } else if (!showHomePage || hasStartedDrawing) {
      p.cursor(p.CROSS); // Show cross cursor when not on home page
    }
    
    // Draw control buttons (home and dark/light mode) in top right
    drawControlButtons(p, textColor, bgColor);
    
    // Draw language menu only on home page
    if (showLanguageMenu && showHomePage && !hasStartedDrawing) {
      drawLanguageMenu(p, textColor, bgColor);
    }
    
    // Show home page if enabled
    if (showHomePage && !hasStartedDrawing) {
      drawHomePage(p, textColor);
      // Don't return here - let language menu show on top
    }
    
    // Draw all stored letters with their current opacity
    const currentTime = p.millis();
    drawnLetters = drawnLetters.filter(letter => {
      const age = currentTime - letter.createdAt;
      const opacity = p.map(age, 0, letterLifespan, 255, 0, true);
      
      if (opacity <= 0) {
        return false; // Remove faded letters
      }
      
      // Draw the letter with fading opacity
      p.push();
      p.translate(letter.x, letter.y);
      p.rotate(letter.angle);
      const letterColor = darkMode ? 240 : 0;
      p.fill(letterColor, opacity);
      p.textSize(letter.size);
      p.text(letter.char, 0, 0);
      p.pop();
      
      return true; // Keep this letter
    });
    
    // Draw new letters if text is ready and mouse is pressed
    // Don't draw if home page is showing
    if (p.mouseIsPressed && p.mouseButton == p.LEFT && textReady && letters.length > 0 && !showHomePage) {
      hasStartedDrawing = true; // Mark that user has started drawing (instructions will never show again)
      
      // Update volume based on Y position (lower Y = higher volume)
      updateVolumeFromY(p);
      
      // Update playback speed based on mouse movement speed
      updatePlaybackSpeedFromMovement(p);
      
      // Synchronize character drawing with audio playback
      let targetCharIndex = counter; // Default to current counter
      
      if (currentAudio && !currentAudio.paused && audioDuration > 0) {
        // Calculate which character should be drawn based on audio position
        const audioProgress = currentAudio.currentTime / audioDuration;
        targetCharIndex = Math.floor(audioProgress * letters.length);
        targetCharIndex = p.constrain(targetCharIndex, 0, letters.length - 1);
      }
      
      var d = p.dist(x, y, p.mouseX, p.mouseY);
      p.textSize(fontSizeMin + d / 2);
      var newLetter = letters.charAt(targetCharIndex);
      stepSize = p.textWidth(newLetter);
      
      // Draw letter if:
      // 1. Mouse has moved enough distance, OR
      // 2. Audio has progressed to a new character (synchronized drawing)
      const audioProgressed = currentAudio && !currentAudio.paused && targetCharIndex > lastDrawnCharIndex;
      const mouseMovedEnough = d > stepSize;
      const shouldDrawLetter = mouseMovedEnough || audioProgressed;
      
      if (shouldDrawLetter) {
        var angle = p.atan2(p.mouseY - y, p.mouseX - x);
        
        // Store the letter instead of drawing it directly
        drawnLetters.push({
          x: x,
          y: y,
          char: newLetter,
          angle: angle + p.random(angleDistortion),
          size: fontSizeMin + d / 2,
          createdAt: currentTime
        });

        lastDrawnCharIndex = targetCharIndex;
        counter = targetCharIndex; // Sync counter with audio position
        
        // Advance position based on mouse movement
        if (mouseMovedEnough) {
          x = x + p.cos(angle) * stepSize;
          y = y + p.sin(angle) * stepSize;
        } else {
          // If only audio progressed, move slightly toward mouse
          x = p.mouseX;
          y = p.mouseY;
        }
        
        // Handle looping
        if (targetCharIndex >= letters.length - 1 && audioProgressed) {
          lastDrawnCharIndex = -1; // Reset for looping
        }
      }
    }
    
    // Show text generation status indicator
    if (!showHomePage || hasStartedDrawing) {
      drawTextStatusIndicator(p, textColor, bgColor);
    }
  };
  
  function drawTextStatusIndicator(p, textColor, bgColor) {
    p.push();
    const centerX = p.width / 2;
    const indicatorY = p.height - 40;
    const t = translations[selectedLanguage] || translations['en'];
    
    if (isLoading) {
      // Show loading indicator
      p.textAlign(p.CENTER, p.CENTER);
      p.textFont(font);
      p.textSize(14);
      p.fill(textColor - 100);
      p.noStroke();
      p.text(t.generatingText || 'Generating text...', centerX, indicatorY);
    } else if (textReady && letters.length > 0 && !audioReady) {
      // Show audio generation indicator
      p.textAlign(p.CENTER, p.CENTER);
      p.textFont(font);
      p.textSize(14);
      p.fill(textColor - 100);
      p.noStroke();
      p.text(t.generatingAudio || 'Generating audio...', centerX, indicatorY);
    } else if (textReady && audioReady && letters.length > 0) {
      // Show ready indicator (fade out after 3 seconds)
      const timeSinceReady = Date.now() - textReadyIndicatorTime;
      const fadeDuration = 3000; // 3 seconds
      if (timeSinceReady < fadeDuration && textReadyIndicatorTime > 0) {
        const opacity = p.map(timeSinceReady, 0, fadeDuration, 255, 0, true);
        p.textAlign(p.CENTER, p.CENTER);
        p.textFont(font);
        p.textSize(14);
        p.fill(textColor - 50, opacity);
        p.noStroke();
        p.text(t.textReady || 'Text ready • Click and drag to draw', centerX, indicatorY);
      }
    } else if (!textReady && !isLoading) {
      // Show prompt to generate text
      p.textAlign(p.CENTER, p.CENTER);
      p.textFont(font);
      p.textSize(14);
      p.fill(textColor - 100);
      p.noStroke();
      p.text(t.pressSpace || 'Press SPACE to generate text', centerX, indicatorY);
    }
    
    p.pop();
  }

  function drawControlButtons(p, textColor, bgColor) {
    p.push();
    const modeButtonSize = 28; // Dark/light mode button size
    const homeButtonSize = 36; // Larger home button
    const buttonY = 15;
    const spacing = 40;
    
    // Dark/Light mode toggle button (always visible) - top left
    const modeX = 15;
    p.fill(textColor);
    p.textAlign(p.CENTER, p.CENTER);
    p.textSize(16); // Smaller icon
    p.noStroke();
    p.text(darkMode ? '☀' : '☾', modeX + modeButtonSize/2, buttonY + modeButtonSize/2);
    
    // Home button (only after space is pressed) - top right, larger
    if (spacePressed) {
      const homeX = p.width - homeButtonSize - 15;
      p.fill(textColor);
      p.textSize(20); // Larger icon for home button
      p.text('⌂', homeX + homeButtonSize/2, buttonY + homeButtonSize/2);
    }
    
    p.pop();
  }

  function drawRoundedRect(p, x, y, w, h, radius) {
    p.beginShape();
    p.vertex(x + radius, y);
    p.vertex(x + w - radius, y);
    p.quadraticVertex(x + w, y, x + w, y + radius);
    p.vertex(x + w, y + h - radius);
    p.quadraticVertex(x + w, y + h, x + w - radius, y + h);
    p.vertex(x + radius, y + h);
    p.quadraticVertex(x, y + h, x, y + h - radius);
    p.vertex(x, y + radius);
    p.quadraticVertex(x, y, x + radius, y);
    p.endShape(p.CLOSE);
  }

  function drawLanguageMenu(p, textColor, bgColor) {
    p.push();
    const menuX = p.width - 100; // Smaller menu, moved closer to edge
    const menuY = 50; // Moved higher
    const itemHeight = 22; // Smaller item height
    const menuWidth = 80; // Smaller menu width
    const cornerRadius = 6; // Smaller corner radius
    const selectedLang = languages[selectedLanguage];
    const buttonCenterX = menuX + menuWidth / 2; // Center X for text
    
    // Draw dropdown button (always visible) with rounded corners and subtle box
    const buttonBg = 255; // White background
    const borderColor = bgColor === 255 ? 230 : 45; // More subtle border color
    
    // Draw box background with white
    p.fill(buttonBg, 250);
    p.stroke(borderColor, 120); // Reduced opacity for subtlety
    p.strokeWeight(1);
    drawRoundedRect(p, menuX - 8, menuY - 8, menuWidth, itemHeight + 8, cornerRadius);
    
    // Draw selected language (centered) - dark text on white background
    p.textFont(font);
    p.textAlign(p.CENTER, p.CENTER);
    p.textSize(11); // Smaller text
    p.fill(0); // Black text for white background
    p.noStroke();
    p.text(selectedLang.native, buttonCenterX, menuY);
    
    // Draw dropdown arrow (smaller, positioned on right)
    p.textAlign(p.RIGHT, p.CENTER);
    p.textSize(9);
    p.fill(100); // Gray arrow on white background
    p.text(languageMenuOpen ? '▲' : '▼', menuX + menuWidth - 8, menuY);
    
    // Draw dropdown list if open with rounded corners and visible box
    if (languageMenuOpen) {
      const dropdownHeight = Object.keys(languages).length * itemHeight + 8;
      
      // Draw dropdown box background with subtle border (white)
      p.fill(255, 255); // White background
      p.stroke(borderColor, 120); // Reduced opacity for subtlety
      p.strokeWeight(1);
      drawRoundedRect(p, menuX - 8, menuY + itemHeight, menuWidth, dropdownHeight, cornerRadius);
      
      p.textAlign(p.CENTER, p.CENTER);
      p.textSize(10); // Smaller text for dropdown items
      let yPos = menuY + itemHeight + 12;
      for (const [code, lang] of Object.entries(languages)) {
        const isSelected = selectedLanguage === code;
        
        // Highlight selected language with rounded corners
        if (isSelected) {
          p.fill(240); // Light gray highlight on white background
          p.noStroke();
          drawRoundedRect(p, menuX - 4, yPos - 10, menuWidth - 8, itemHeight - 2, 4);
        }
        
        // Draw language name (centered) - dark text on white background
        p.fill(0); // Black text for white background
        p.noStroke();
        p.text(lang.native, buttonCenterX, yPos);
        
        yPos += itemHeight;
      }
    }
    
    p.pop();
  }

  function drawHomePage(p, textColor) {
    p.push();
    p.textFont(font);
    p.textAlign(p.CENTER, p.CENTER);
    
    const centerX = p.width / 2;
    const centerY = p.height / 2;
    const t = translations[selectedLanguage] || translations['en'];
    
    // Title: Machine Forgetting
    p.textSize(64);
    p.fill(textColor);
    p.noStroke();
    p.text(t.title, centerX, centerY - 100);
    
    // Subtitle: Programmed decay and the upheavals of Entropy
    p.textSize(20);
    p.fill(textColor - 20);
    p.text(t.subtitle3, centerX, centerY - 20);
    
    // Instructions
    p.textSize(18);
    p.fill(textColor - 50);
    p.text(t.instruction, centerX, centerY + 100);
    
    // Subtle hint about controls
    p.textSize(14);
    p.fill(textColor - 80);
    p.text(t.hint, centerX, centerY + 140);
    
    // Credits at the bottom
    p.textSize(11);
    p.fill(textColor - 100);
    p.textAlign(p.LEFT, p.BOTTOM);
    const creditsY = p.height - 20;
    
    // Credits text split into parts
    const creditText1 = 'Concept and programming by ';
    const nameText = 'Marlon Barrios Solano';
    const creditText2 = ' • Powered by OpenAI (GPT-4, TTS-1) • p5.js';
    const repoText = ' • Repository';
    
    // Calculate positions for centered text with clickable name and repo
    const creditWidth1 = p.textWidth(creditText1);
    const nameWidth = p.textWidth(nameText);
    const creditWidth2 = p.textWidth(creditText2);
    const repoWidth = p.textWidth(repoText);
    const totalWidth = creditWidth1 + nameWidth + creditWidth2 + repoWidth;
    
    const startX = centerX - totalWidth / 2;
    const nameX = startX + creditWidth1;
    const repoX = nameX + nameWidth + creditWidth2;
    const nameY = creditsY - 15;
    
    // Draw first part of credits
    p.fill(textColor - 100);
    p.text(creditText1, startX, nameY);
    
    // Portfolio link on name (clickable)
    const nameLinkLeft = nameX;
    const nameLinkRight = nameX + nameWidth;
    const nameLinkTop = nameY - 8;
    const nameLinkBottom = nameY + 8;
    
    // Repository link (clickable)
    const repoLinkLeft = repoX;
    const repoLinkRight = repoX + repoWidth;
    const repoLinkTop = nameY - 8;
    const repoLinkBottom = nameY + 8;
    
    // Check if mouse is hovering over name link
    const isHoveringName = p.mouseX >= nameLinkLeft && p.mouseX <= nameLinkRight &&
                           p.mouseY >= nameLinkTop && p.mouseY <= nameLinkBottom;
    
    // Check if mouse is hovering over repo link
    const isHoveringRepo = p.mouseX >= repoLinkLeft && p.mouseX <= repoLinkRight &&
                           p.mouseY >= repoLinkTop && p.mouseY <= repoLinkBottom;
    
    // Change cursor to pointer when hovering over links
    if ((isHoveringName || isHoveringRepo) && showHomePage && !hasStartedDrawing) {
      p.cursor(p.HAND);
    }
    
    // Draw name with underline and different color when hovering
    if (isHoveringName) {
      p.fill(textColor - 60); // Lighter when hovering
    } else {
      p.fill(textColor - 100);
    }
    p.text(nameText, nameX, nameY);
    
    // Draw underline on name
    p.stroke(isHoveringName ? textColor - 60 : textColor - 100);
    p.strokeWeight(1);
    p.line(nameLinkLeft, nameY + 2, nameLinkRight, nameY + 2);
    p.noStroke();
    
    // Draw second part of credits
    p.fill(textColor - 100);
    p.text(creditText2, nameX + nameWidth, nameY);
    
    // Draw repository link with underline and different color when hovering
    if (isHoveringRepo) {
      p.fill(textColor - 60); // Lighter when hovering
    } else {
      p.fill(textColor - 100);
    }
    p.text(repoText, repoX, nameY);
    
    // Draw underline on repo link
    p.stroke(isHoveringRepo ? textColor - 60 : textColor - 100);
    p.strokeWeight(1);
    p.line(repoLinkLeft, nameY + 2, repoLinkRight, nameY + 2);
    p.noStroke();
    
    p.pop();
  }

  p.mousePressed = function() {
    // Check if clicking on portfolio link (Marlon's name) or repository link (only on home page)
    if (showHomePage && !hasStartedDrawing) {
      const centerX = p.width / 2;
      const creditsY = p.height - 20;
      const nameY = creditsY - 15;
      const nameText = 'Marlon Barrios Solano';
      const creditText1 = 'Concept and programming by ';
      const creditText2 = ' • Powered by OpenAI (GPT-4, TTS-1) • p5.js';
      const repoText = ' • Repository';
      
      p.textSize(11);
      const creditWidth1 = p.textWidth(creditText1);
      const nameWidth = p.textWidth(nameText);
      const creditWidth2 = p.textWidth(creditText2);
      const repoWidth = p.textWidth(repoText);
      const totalWidth = creditWidth1 + nameWidth + creditWidth2 + repoWidth;
      
      const startX = centerX - totalWidth / 2;
      const nameX = startX + creditWidth1;
      const repoX = nameX + nameWidth + creditWidth2;
      
      // Name link bounds
      const nameLinkLeft = nameX;
      const nameLinkRight = nameX + nameWidth;
      const nameLinkTop = nameY - 8;
      const nameLinkBottom = nameY + 8;
      
      // Repository link bounds
      const repoLinkLeft = repoX;
      const repoLinkRight = repoX + repoWidth;
      const repoLinkTop = nameY - 8;
      const repoLinkBottom = nameY + 8;
      
      // Check if clicking on name link
      if (p.mouseX >= nameLinkLeft && p.mouseX <= nameLinkRight &&
          p.mouseY >= nameLinkTop && p.mouseY <= nameLinkBottom) {
        window.open('https://marlonbarrios.github.io/', '_blank');
        return; // Exit early - don't trigger other actions
      }
      
      // Check if clicking on repository link
      if (p.mouseX >= repoLinkLeft && p.mouseX <= repoLinkRight &&
          p.mouseY >= repoLinkTop && p.mouseY <= repoLinkBottom) {
        window.open('https://github.com/marlonbarrios/machine_forgetting_textvoice', '_blank');
        return; // Exit early - don't trigger other actions
      }
    }
    
    const modeButtonSize = 28;
    const homeButtonSize = 36; // Larger home button
    const buttonY = 15;
    
    // Check if clicking on dark/light mode button (top left)
    const modeX = 15;
    if (p.mouseX >= modeX && p.mouseX <= modeX + modeButtonSize &&
        p.mouseY >= buttonY && p.mouseY <= buttonY + modeButtonSize) {
      darkMode = !darkMode;
      return; // Exit early - don't trigger drawing
    }
    
    // Check if clicking on home button (only if space has been pressed) - top right
    // Make it larger and ensure it doesn't trigger drawing
    if (spacePressed) {
      const homeX = p.width - homeButtonSize - 15;
      const homeLeft = homeX;
      const homeRight = homeX + homeButtonSize;
      const homeTop = buttonY;
      const homeBottom = buttonY + homeButtonSize;
      
      if (p.mouseX >= homeLeft && p.mouseX <= homeRight &&
          p.mouseY >= homeTop && p.mouseY <= homeBottom) {
        // Reset to home page state
        showHomePage = true;
        hasStartedDrawing = false;
        languageMenuOpen = false;
        
        // Clear all drawn text and canvas
        drawnLetters = [];
        letters = '';
        counter = 0;
        lastDrawnCharIndex = -1; // Reset character tracking
        audioDuration = 0; // Reset audio duration
        x = 0;
        y = 0;
        
        // Clear canvas background
        const bgColor = darkMode ? 20 : 255;
        p.background(bgColor);
        
        // Reset text and audio states
        textReady = false;
        audioReady = false;
        isLoading = false;
        textReadyIndicatorTime = 0;
        
        // Clear audio
        if (currentAudio) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
          currentAudio.onended = null;
          currentAudio = null;
        }
        if (audioUrl) {
          URL.revokeObjectURL(audioUrl);
          audioUrl = null;
        }
        shouldLoopAudio = false;
        isAudioPlaying = false;
        
        // Cancel browser speech synthesis if active
        if ('speechSynthesis' in window) {
          speechSynthesis.cancel();
        }
        
        return; // Exit early - don't trigger drawing
      }
    }
    
    // Check if clicking on language dropdown (only on home page)
    if (showLanguageMenu && showHomePage && !hasStartedDrawing) {
      const menuX = p.width - 100;
      const menuY = 50;
      const itemHeight = 22;
      const menuWidth = 80;
      const padding = 8;
      const menuLeft = menuX - padding;
      const menuRight = menuX + menuWidth - padding;
      const buttonTop = menuY - padding;
      const buttonBottom = menuY + itemHeight;
      
      // Check if clicking in the menu button area
      if (p.mouseX >= menuLeft && p.mouseX <= menuRight &&
          p.mouseY >= buttonTop && p.mouseY <= buttonBottom) {
        languageMenuOpen = !languageMenuOpen; // Toggle dropdown
        return; // Exit early - don't trigger drawing
      }
      
      // Check if clicking on dropdown items (when open)
      if (languageMenuOpen) {
        const dropdownTop = menuY + itemHeight;
        const dropdownBottom = dropdownTop + (Object.keys(languages).length * itemHeight) + padding - 4;
        
        if (p.mouseX >= menuLeft && p.mouseX <= menuRight &&
            p.mouseY >= dropdownTop && p.mouseY <= dropdownBottom) {
          // Calculate which language was clicked
          const relativeY = p.mouseY - dropdownTop;
          const clickedIndex = Math.floor(relativeY / itemHeight);
          const langCodes = Object.keys(languages);
          
          if (clickedIndex >= 0 && clickedIndex < langCodes.length) {
            selectedLanguage = langCodes[clickedIndex];
            languageMenuOpen = false; // Close dropdown after selection
            // Clear audio URL so new text will be generated in the new language
            if (audioUrl) {
              URL.revokeObjectURL(audioUrl);
              audioUrl = null;
            }
            return; // Exit early - don't trigger drawing
          }
        }
      }
      
      // Close dropdown if clicking outside menu area
      if (languageMenuOpen) {
        const dropdownTop = menuY + itemHeight;
        const dropdownBottom = dropdownTop + (Object.keys(languages).length * itemHeight) + padding - 4;
        const menuAreaTop = buttonTop;
        const menuAreaBottom = dropdownBottom;
        
        // Check if click is outside the entire menu area
        if (!(p.mouseX >= menuLeft && p.mouseX <= menuRight &&
              p.mouseY >= menuAreaTop && p.mouseY <= menuAreaBottom)) {
          languageMenuOpen = false;
        }
      }
    } else {
      // Close dropdown if not on home page
      languageMenuOpen = false;
    }
    
    // Don't start drawing if home page is showing (unless clicking outside menu)
    if (showHomePage && !hasStartedDrawing) {
      return; // Exit early - don't start drawing on home page
    }
    
    x = p.mouseX;
    y = p.mouseY;
    
    // Initialize previous mouse position for speed calculation
    prevMouseX = p.mouseX;
    prevMouseY = p.mouseY;
    
    // Hide home page when user starts interacting
    if (showHomePage) {
      showHomePage = false;
    }
    
    // Mark that user has started drawing - this will hide instructions
    // Only allow drawing if both text and audio are ready
    if (textReady && audioReady && letters.length > 0 && audioUrl) {
      hasStartedDrawing = true;
    }
    
    // Start/resume playing text when mouse is pressed and loop while pressed
    // Only play if both text and audio are ready
    if (textReady && letters.length > 0 && audioReady && audioUrl) {
      shouldLoopAudio = true;
      
      // Resume or start playing audio
      speakText(letters); // Speak the exact same text that's being drawn
      
      // Set initial volume based on Y position
      updateVolumeFromY(p);
    }
  };

  function updateVolumeFromY(p) {
    if (currentAudio) {
      // Map Y position to volume (0 to 1)
      // Lower Y (top of screen) = higher volume (1.0)
      // Higher Y (bottom of screen) = lower volume (0.0)
      const normalizedY = p.constrain(p.mouseY / p.height, 0, 1);
      const volume = 1.0 - normalizedY; // Higher Y = lower volume (reversed)
      currentAudio.volume = p.constrain(volume, 0, 1);
    }
  }

  function updatePlaybackSpeedFromMovement(p) {
    if (currentAudio) {
      // Calculate distance moved since last frame (speed)
      const distanceMoved = p.dist(prevMouseX, prevMouseY, p.mouseX, p.mouseY);
      
      // Map movement speed to playback rate
      // Faster movement = faster playback rate
      // Normalize speed (assuming max speed around 50 pixels per frame)
      const normalizedSpeed = p.constrain(distanceMoved / 50, 0, 2);
      
      // Map to playback rate: 0.5x (slow) to 2.0x (fast)
      // Base rate of 0.5x, increases with speed up to 2.0x
      const playbackRate = 0.5 + (normalizedSpeed * 1.5);
      currentAudio.playbackRate = p.constrain(playbackRate, 0.5, 2.0);
      
      // Update previous position for next frame
      prevMouseX = p.mouseX;
      prevMouseY = p.mouseY;
    }
  }

  p.mouseReleased = function() {
    // Pause audio when mouse is released (don't reset position)
    shouldLoopAudio = false;
    if (currentAudio && !currentAudio.paused) {
      currentAudio.pause();
      isAudioPlaying = false;
    }
  };

  p.keyReleased = function() {
    if (p.key == 's' || p.key == 'S') p.saveCanvas('drawing', 'png');
    if (p.keyCode == p.DELETE || p.keyCode == p.BACKSPACE) {
      p.background(255);
      counter = 0;
      hasStartedDrawing = false; // Reset drawing flag when clearing
      drawnLetters = []; // Clear all drawn letters
    }
  };

  p.keyPressed = function() {
    // angleDistortion ctrls arrowkeys up/down
    if (p.keyCode == p.UP_ARROW) angleDistortion += 0.1;
    if (p.keyCode == p.DOWN_ARROW) angleDistortion -= 0.1;
    
    // Space bar: generate new text and hide home page
    // Don't generate text if home page is showing (user needs to be on home page first)
    if (p.keyCode === 32) { // Space key
      // Only generate text if not on home page, or if home page is showing (then hide it and generate)
      if (showHomePage) {
        showHomePage = false; // Hide home page when space is pressed
        spacePressed = true; // Mark that space has been pressed
        if (!isLoading) {
          generateText();
        }
      } else if (!showHomePage && !isLoading) {
        // If not on home page, allow generating new text
        spacePressed = true;
        if (!isLoading) {
          generateText();
        }
      }
    }
  };

  async function generateText() {
    // Prevent multiple simultaneous calls
    if (isLoading) {
      return;
    }
    
    try {
      isLoading = true; // Set loading state at the start
      textReadyIndicatorTime = 0; // Reset indicator time when starting generation
      textReady = false; // Reset text ready state
      audioReady = false; // Reset audio ready state
      
      const t = translations[selectedLanguage] || translations['en'];
      const prompt = t.systemPrompt || translations['en'].systemPrompt;
      
      // Call API route instead of OpenAI directly
      const response = await fetch(`${API_BASE}/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ prompt })
      });

      if (!response.ok) {
        const errorText = await response.text();
        let errorData;
        try {
          errorData = JSON.parse(errorText);
        } catch (e) {
          errorData = { error: errorText };
        }
        console.error('API error:', response.status, errorData);
        throw new Error(errorData.error || `API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      if (!data.text) {
        throw new Error('Invalid response from API: missing text field');
      }
      const generatedText = data.text;
      // Clean the text and use it for drawing
      letters = generatedText.replace(/\n/g, ' ').trim();
      counter = 0; // Reset counter to start from beginning
      lastDrawnCharIndex = -1; // Reset character tracking
      audioDuration = 0; // Reset audio duration
      textReady = true; // Text is ready (invisible indicator)
      textReadyIndicatorTime = Date.now(); // Set timestamp for ready indicator
      isLoading = false;
      hasGeneratedOnce = true;
      hasStartedDrawing = false; // Reset drawing flag when new text is generated
      shouldLoopAudio = false; // Reset audio loop flag
      audioReady = false; // Reset audio ready flag
      
      // Stop any currently playing audio and clear audio URL
      // This ensures the spoken text will match the new written text
      if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio.onended = null;
        currentAudio = null;
      }
      if (audioUrl) {
        URL.revokeObjectURL(audioUrl);
        audioUrl = null;
      }
      isAudioPlaying = false; // Reset audio playing flag so new text can be spoken
      
      // Generate audio automatically when text is ready
      await generateAudioForText(letters);
    } catch (err) {
      console.error("An error occurred generating text:", err);
      isLoading = false;
      textReady = false;
    }
  }

  async function generateAudioForText(text) {
    // Generate audio for the text without playing it
    try {
      audioReady = false;
      
      // Clear old audio URL
      if (audioUrl) {
        URL.revokeObjectURL(audioUrl);
        audioUrl = null;
      }
      
      // Call API route instead of OpenAI directly
      const response = await fetch(`${API_BASE}/audio`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ text, voice: 'alloy' })
      });

      if (!response.ok) {
        const errorText = await response.text();
        let errorData;
        try {
          errorData = JSON.parse(errorText);
        } catch (e) {
          errorData = { error: errorText };
        }
        console.error('Audio API error:', response.status, errorData);
        throw new Error(errorData.error || `API error: ${response.status} ${response.statusText}`);
      }

      // Convert the response to a blob and store URL
      const audioBlob = await response.blob();
      if (audioBlob.size === 0) {
        throw new Error('Received empty audio response');
      }
      audioUrl = URL.createObjectURL(audioBlob);
      audioReady = true; // Mark audio as ready
      textReadyIndicatorTime = Date.now(); // Update timestamp when audio is ready (for "ready" indicator)
    } catch (err) {
      console.error("An error occurred generating audio:", err);
      audioReady = false;
    }
  }

  async function speakText(text) {
    try {
      // If audio is already playing, don't restart it
      if (isAudioPlaying && currentAudio && !currentAudio.paused) {
        return;
      }
      
      // If we have paused audio, resume it
      if (currentAudio && currentAudio.paused) {
        isAudioPlaying = true;
        // Don't reset counter on resume - maintain position
        currentAudio.play();
        return;
      }
      
      // Cancel any browser speech synthesis
      if ('speechSynthesis' in window) {
        speechSynthesis.cancel();
      }
      
      // If we already have audio URL (pre-generated), use it
      if (!audioUrl) {
        // Fallback: generate audio on the fly if not pre-generated
        await generateAudioForText(text);
      }
      
      // Ensure audio is ready before playing
      if (!audioUrl || !audioReady) {
        isAudioPlaying = false;
        return;
      }
      
      // Create new audio element from the URL
      const audio = new Audio(audioUrl);
      currentAudio = audio;
      isAudioPlaying = true;
      
      // Track audio duration for synchronization
      audio.addEventListener('loadedmetadata', () => {
        audioDuration = audio.duration;
      });
      
      // Reset synchronization when audio starts
      audio.addEventListener('play', () => {
        audioStartTime = Date.now();
        lastDrawnCharIndex = -1; // Reset character tracking
        counter = 0; // Reset counter to start
        // Note: x and y will be set when mouse is pressed
      });
      
      // Play the audio
      audio.play();
      
      // When audio ends, loop if mouse is still pressed
      audio.onended = () => {
        isAudioPlaying = false; // Reset flag when audio ends
        if (shouldLoopAudio && textReady && letters.length > 0) {
          // Reset to beginning and play again for looping
          audio.currentTime = 0;
          lastDrawnCharIndex = -1; // Reset character tracking for loop
          counter = 0; // Reset counter
          audio.play();
        } else {
          // Don't clean up - keep audio paused for resume
          isAudioPlaying = false;
        }
      };
      
      // Handle audio errors
      audio.onerror = () => {
        isAudioPlaying = false;
        currentAudio = null;
      };
    } catch (err) {
      console.error("An error occurred speaking text:", err);
      isAudioPlaying = false;
      // Fallback to browser speech synthesis if OpenAI TTS fails
      if ('speechSynthesis' in window) {
        // Stop any ongoing speech synthesis first
        speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.onend = () => {
          isAudioPlaying = false;
          if (shouldLoopAudio && textReady && letters.length > 0) {
            setTimeout(() => {
              if (shouldLoopAudio && !isAudioPlaying) {
                speakText(text);
              }
            }, 50);
          }
        };
        speechSynthesis.speak(utterance);
      }
    }
  }
};

function onReady() {
  // API key is now handled server-side via Vercel API routes
  // No need to check for API key in frontend
  const mainElt = document.querySelector('main');
  new p5(sketch, mainElt);
}

if (document.readyState === 'complete') {
  onReady();
} else {
  document.addEventListener("DOMContentLoaded", onReady);
}